{"version":3,"sources":["webpack:///webpack/bootstrap 5d8ed72b602882ffd326","webpack:///./node_modules/metal/lib/metal.js","webpack:///./node_modules/metal-dom/lib/dom.js","webpack:///./node_modules/metal-events/lib/events.js","webpack:///./node_modules/metal-incremental-dom/lib/data.js","webpack:///./node_modules/metal-component/lib/all/component.js","webpack:///./node_modules/metal-state/lib/all/state.js","webpack:///./node_modules/metal-dom/lib/all/dom.js","webpack:///./node_modules/process/browser.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/metal-incremental-dom/lib/IncrementalDomRenderer.js","webpack:///./node_modules/metal-incremental-dom/lib/incremental-dom-aop.js","webpack:///./node_modules/metal-dom/lib/domData.js","webpack:///./node_modules/metal-state/lib/validators.js","webpack:///./node_modules/metal/lib/core.js","webpack:///./node_modules/metal-events/lib/EventHandle.js","webpack:///./node_modules/metal-jsx/lib/JSXComponent.js","webpack:///./node_modules/metal-incremental-dom/lib/incremental-dom.js","webpack:///./node_modules/metal-incremental-dom/lib/changes.js","webpack:///./node_modules/metal-incremental-dom/lib/children/children.js","webpack:///./node_modules/metal-incremental-dom/lib/callArgs.js","webpack:///./node_modules/metal-dom/lib/DomEventHandle.js","webpack:///./node_modules/metal-dom/lib/features.js","webpack:///./node_modules/metal-incremental-dom/lib/render/render.js","webpack:///./node_modules/metal-component/lib/events/events.js","webpack:///./node_modules/metal-component/lib/ComponentDataManager.js","webpack:///./node_modules/metal-component/lib/ComponentRenderer.js","webpack:///./node_modules/metal-jsx/lib/JSXRenderer.js","webpack:///./src/index.ts","webpack:///./src/agp.tsx","webpack:///./node_modules/metal-jsx/lib/all/jsx.js","webpack:///./node_modules/metal/lib/coreNamed.js","webpack:///./node_modules/metal/lib/array/array.js","webpack:///./node_modules/metal/lib/async/async.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./node_modules/metal/lib/disposable/Disposable.js","webpack:///./node_modules/metal/lib/object/object.js","webpack:///./node_modules/metal/lib/string/string.js","webpack:///./node_modules/metal-state/lib/Config.js","webpack:///./node_modules/metal-state/lib/State.js","webpack:///./node_modules/metal-events/lib/EventEmitter.js","webpack:///./node_modules/metal-events/lib/EventEmitterProxy.js","webpack:///./node_modules/metal-events/lib/EventHandler.js","webpack:///./node_modules/metal-jsx/lib/DangerouslySetHTML.js","webpack:///./node_modules/metal-jsx/lib/iDOMHelpers.js","webpack:///./node_modules/incremental-dom/dist/incremental-dom-cjs.js","webpack:///./node_modules/incremental-dom-string/dist/incremental-dom-string.js","webpack:///./node_modules/metal-incremental-dom/lib/render/patch.js","webpack:///./node_modules/metal-dom/lib/domNamed.js","webpack:///./node_modules/metal-dom/lib/DomDelegatedEventHandle.js","webpack:///./node_modules/metal-dom/lib/DomEventEmitterProxy.js","webpack:///./node_modules/metal-dom/lib/globalEval.js","webpack:///./node_modules/metal-dom/lib/globalEvalStyles.js","webpack:///./node_modules/metal-dom/lib/events.js","webpack:///./node_modules/metal-incremental-dom/lib/render/attributes.js","webpack:///./node_modules/metal-component/lib/Component.js","webpack:///./node_modules/metal-component/lib/sync/sync.js","webpack:///./node_modules/metal-component/lib/ComponentRegistry.js","webpack:///./node_modules/metal-incremental-dom/lib/cleanup/unused.js","webpack:///./node_modules/metal-jsx/lib/JSXDataManager.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;AChDA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA,kB;;;;;;;AC7BA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA,8C;;;;;;;AC7BA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;AC5BA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA,wD;;;;;;;ACzCA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA,gC;;;;;;;ACxBA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;ACvDA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACpBA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,sBAAsB;AACnC;AACA,aAAa,gBAAgB;AAC7B;AACA,aAAa,SAAS;AACtB,cAAc,WAAW;AACzB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA,2B;;;;;;;AC5TA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0F;;;;;;;ACxHA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,EAAE;AACf;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,0B;;;;;;;ACzDA;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,YAAY;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA,YAAY,YAAY;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,YAAY,YAAY;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;;AC/PA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA,oB;;;;;;;AC7BA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,8B;;;;;;;ACzFA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,kCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA,sCAAsC;;AAEtC,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;;AAEA,+B;;;;;;;8CCzGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,C;;;;;;;;ACxBA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA,C;;;;;;;ACjDA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,YAAY;AACvB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA,mEAAmE,eAAe;AAClF;AACA;;AAEA;AACA,C;;;;;;;AClMA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACzCA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,iC;;;;;;;ACzDA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;AACA;;AAEA,2B;;;;;;;ACxFA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe;AAClF;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,YAAY;AACvB,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,YAAY;AACvB;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,SAAS;AACpB,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACnmBA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,YAAY,qBAAqB;AACjC;AACA;AACA,0CAA0C;AAC1C;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,WAAW,mBAAmB,sCAAsC;AACpE,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,C;;;;;;;ACpEA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,mBAAmB;AAChC;AACA,aAAa,YAAY;AACzB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,6C;;;;;;;ACnMA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,aAAa,WAAW;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,wBAAwB;AACrC;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,0C;;;;;;;ACtFA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,qDAAqD,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,wCAAwC,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE;;AAExe;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;;AAEA,+B;;;;;;;;;;;;;;;;;;gBCpK4B;;;;;;;;;;;;;;;;;;ACE5B;;;;;;;;;;;;IACW;;;;;;;;;;;;AACI,oBAAI,IACf;AAEM;;;;AAIN;;;AAGG;;;;;;QACP;kBAAmB,I;;;;;;;ACfnB;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA,8C;;;;;;;+CCvBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,YAAY,EAAE;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA,0B;;;;;;;;ACvUA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC,aAAa,UAAU;AACvB,cAAc,UAAU;AACxB;;AAEA,EAAE;AACF;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,EAAE;AACf,cAAc,QAAQ;AACtB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,wB;;;;;;;ACxIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,QAAQ;AACtB;;AAEA,cAAc,8BAA8B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;;AC7OA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;ACzLD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,6B;;;;;;;ACrEA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ,yCAAyC;AAC9D;AACA,cAAc,EAAE;AAChB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,qBAAqB;AAClC,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,yB;;;;;;;ACxGA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd;AACA,aAAa,OAAO,iCAAiC,QAAQ;AAC7D;;AAEA,EAAE;AACF;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA,EAAE;AACF;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,yB;;;;;;;ACtHA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,YAAY,sBAAsB;AAClC,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;;AAGF;AACA;AACA,YAAY,sCAAsC;AAClD,aAAa,oBAAoB;AACjC;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA;AACA,YAAY,YAAY;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA;AACA,YAAY,YAAY;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA;AACA,YAAY,EAAE;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA;AACA,YAAY,YAAY;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA,yB;;;;;;;AC1RA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,qDAAqD,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,wCAAwC,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE;;AAExe;;AAEA;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA,+CAA+C;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,EAAE;AACf;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB;AACA,cAAc,EAAE;AAChB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,aAAa,EAAE;AACf,cAAc,EAAE;AAChB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,cAAc,QAAQ;AACtB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE,aAAa,0BAA0B;AACvC;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,QAAQ;AACtB;AACA;;AAEA,EAAE;AACF;;;AAGA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA,EAAE;AACF;;;AAGA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,YAAY;AACzB;AACA;;AAEA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,cAAc,QAAQ;AACtB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,gCAAgC;AAChC;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;;AC/yBA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,mBAAmB;AAC/B,aAAa,EAAE;AACf;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA,cAAc,aAAa;AAC3B;;AAEA,EAAE;AACF;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA,cAAc,aAAa;AAC3B,aAAa,UAAU;AACvB;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,MAAM;AACpB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA,aAAa,UAAU;AACvB,cAAc,aAAa;AAC3B;;AAEA,EAAE;AACF;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,UAAU;AACvB;AACA;;AAEA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc,aAAa;AAC3B;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc,aAAa;AAC3B;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,UAAU;AACvB,cAAc,sBAAsB;AACpC;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,EAAE;AAChB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA,+B;;;;;;;ACjhBA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,OAAO;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,YAAY;AACxB,aAAa,aAAa;AAC1B;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;;AAEA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,oC;;;;;;;ACzOA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;;;AAGA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,+B;;;;;;;ACpFA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA,qC;;;;;;;8CCjEA;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,oC;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;;AAEA,WAAW,MAAM;AACjB;;AAEA,WAAW,MAAM;AACjB;;AAEA,WAAW,UAAU;AACrB;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,8DAA8D;AACzE,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C,aAAa,aAAa;AAC1B,aAAa,GAAG;AAChB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,aAAa;AACxB;AACA,WAAW,GAAG;AACd,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB;AACA;AACA,WAAW,GAAG;AACd,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,6BAA6B,SAAS,IAAI;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,0BAA0B;AACrC;AACA;AACA;AACA,kCAAkC,MAAM;;AAExC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB,WAAW,EAAE;AACb;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yBAAyB,uBAAuB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,mCAAmC,yBAAyB;AAC5D;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,sBAAsB;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,4BAA4B,OAAO;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,8CAA8C;AACzD;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,OAAO;;AAElC;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+C;;;;;;;AC14CA;AACA;AACA;AACA,8DAA8D;AAC9D,CAAC,4BAA4B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB;AACA,WAAW,GAAG;AACd,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,8CAA8C;AACzD;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,qBAAqB;AACzC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,cAAc;;AAE5D,CAAC;;;;;;;;AC/QD;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;AClHA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,qBAAqB;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,oBAAoB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB;AACA;AACA;AACA,qEAAqE;AACrE;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,2BAA2B;AACtC,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA,WAAW,mBAAmB;AAC9B;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,OAAO;AAClB,WAAW,mBAAmB;AAC9B;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,mBAAmB;AAC9B;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,qBAAqB;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACh2BA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,yEAAyE;AACzE,uEAAuE;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,0C;;;;;;;AC1EA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,qDAAqD,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,wCAAwC,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE;;AAExe;;AAEA;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,uC;;;;;;;AC1GA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB;AACA,aAAa,YAAY;AACzB;AACA,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB;AACA,aAAa,YAAY;AACzB;AACA,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB;AACA,aAAa,YAAY;AACzB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB;AACA,aAAa,YAAY;AACzB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,6B;;;;;;;ACvJA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB;AACA,aAAa,YAAY;AACzB;AACA,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB;AACA,aAAa,YAAY;AACzB;AACA,eAAe,QAAQ;AACvB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB;AACA,aAAa,YAAY;AACzB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,mC;;;;;;;ACrIA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF,CAAC,E;;;;;;;AC9CD;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACtLA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,qDAAqD,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,wCAAwC,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE;;AAExe;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M,kCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,gBAAgB;AAChB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,mBAAmB;AAChC;AACA,cAAc,aAAa;AAC3B;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE,oCAAoC;AACnD;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA,+BAA+B;AAC/B,IAAI;AACJ;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB,cAAc;AACd;;AAEA,EAAE;AACF;;;AAGA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,gBAAgB;AAC7B;AACA,aAAa,SAAS;AACtB,cAAc,WAAW;AACzB;;AAEA,EAAE;AACF;;;AAGA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B;;AAEA,EAAE;AACF;;;AAGA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA,aAAa,EAAE,kBAAkB;AACjC;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,gBAAgB;AAC7B;AACA,cAAc,QAAQ;AACtB;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,WAAW,mCAAmC,wCAAwC;AACtF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4B;;;;;;;ACr3BA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;AC9DA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;;AAEA,oC;;;;;;;AC9EA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;AChDA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;;AAEA,4CAA4C;AAC5C;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,uC","file":"../dist/index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5d8ed72b602882ffd326","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;\n\nvar _core = require('./core');\n\nObject.keys(_core).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _core[key];\n    }\n  });\n});\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _array = require('./array/array');\n\nvar _array2 = _interopRequireDefault(_array);\n\nvar _async = require('./async/async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _Disposable = require('./disposable/Disposable');\n\nvar _Disposable2 = _interopRequireDefault(_Disposable);\n\nvar _object = require('./object/object');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _string = require('./string/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.array = _array2.default;\nexports.async = _async2.default;\nexports.Disposable = _Disposable2.default;\nexports.object = _object2.default;\nexports.string = _string2.default;\nexports.default = _core2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/metal.js\n// module id = 0\n// module chunks = 0","'use strict';\n\n// This file exists just for backwards compatibility, making sure that old\n// default imports for this file still work. It's best to use the named exports\n// for each function instead though, since that allows bundlers like Rollup to\n// reduce the bundle size by removing unused code.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dom = undefined;\n\nvar _domNamed = require('./domNamed');\n\nObject.keys(_domNamed).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _domNamed[key];\n    }\n  });\n});\n\nvar dom = _interopRequireWildcard(_domNamed);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.default = dom;\nexports.dom = dom;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/dom.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventHandler = exports.EventHandle = exports.EventEmitterProxy = exports.EventEmitter = undefined;\n\nvar _EventEmitter = require('./EventEmitter');\n\nvar _EventEmitter2 = _interopRequireDefault(_EventEmitter);\n\nvar _EventEmitterProxy = require('./EventEmitterProxy');\n\nvar _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);\n\nvar _EventHandle = require('./EventHandle');\n\nvar _EventHandle2 = _interopRequireDefault(_EventHandle);\n\nvar _EventHandler = require('./EventHandler');\n\nvar _EventHandler2 = _interopRequireDefault(_EventHandler);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _EventEmitter2.default;\nexports.EventEmitter = _EventEmitter2.default;\nexports.EventEmitterProxy = _EventEmitterProxy2.default;\nexports.EventHandle = _EventHandle2.default;\nexports.EventHandler = _EventHandler2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-events/lib/events.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearData = clearData;\nexports.getData = getData;\nvar RENDERER_DATA = '__METAL_IC_RENDERER_DATA__';\n\n/**\n * Removes the incremental dom renderer data object for this component.\n * @param {!Component} component\n */\nfunction clearData(component) {\n  component[RENDERER_DATA] = null;\n}\n\n/**\n * Gets the incremental dom renderer data object for this component, creating\n * it if it doesn't exist yet.\n * @param {!Component} component\n * @return {!Object}\n */\nfunction getData(component) {\n  if (!component[RENDERER_DATA]) {\n    component[RENDERER_DATA] = {};\n  }\n  return component[RENDERER_DATA];\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/data.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ComponentRenderer = exports.ComponentRegistry = exports.ComponentDataManager = exports.Component = undefined;\n\nvar _events = require('../events/events');\n\nObject.keys(_events).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _events[key];\n    }\n  });\n});\n\nvar _Component = require('../Component');\n\nvar _Component2 = _interopRequireDefault(_Component);\n\nvar _ComponentDataManager = require('../ComponentDataManager');\n\nvar _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);\n\nvar _ComponentRegistry = require('../ComponentRegistry');\n\nvar _ComponentRegistry2 = _interopRequireDefault(_ComponentRegistry);\n\nvar _ComponentRenderer = require('../ComponentRenderer');\n\nvar _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Component2.default;\nexports.Component = _Component2.default;\nexports.ComponentDataManager = _ComponentDataManager2.default;\nexports.ComponentRegistry = _ComponentRegistry2.default;\nexports.ComponentRenderer = _ComponentRenderer2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-component/lib/all/component.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.State = exports.Config = exports.validators = undefined;\n\nvar _validators = require('../validators');\n\nvar _validators2 = _interopRequireDefault(_validators);\n\nvar _Config = require('../Config');\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _State = require('../State');\n\nvar _State2 = _interopRequireDefault(_State);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _State2.default;\nexports.validators = _validators2.default;\nexports.Config = _Config2.default;\nexports.State = _State2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-state/lib/all/state.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.globalEvalStyles = exports.globalEval = exports.features = exports.DomEventHandle = exports.DomEventEmitterProxy = exports.domData = undefined;\n\nvar _dom = require('../dom');\n\nObject.keys(_dom).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _dom[key];\n    }\n  });\n});\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nvar _domData = require('../domData');\n\nvar _domData2 = _interopRequireDefault(_domData);\n\nvar _DomEventEmitterProxy = require('../DomEventEmitterProxy');\n\nvar _DomEventEmitterProxy2 = _interopRequireDefault(_DomEventEmitterProxy);\n\nvar _DomEventHandle = require('../DomEventHandle');\n\nvar _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);\n\nvar _features = require('../features');\n\nvar _features2 = _interopRequireDefault(_features);\n\nvar _globalEval = require('../globalEval');\n\nvar _globalEval2 = _interopRequireDefault(_globalEval);\n\nvar _globalEvalStyles = require('../globalEvalStyles');\n\nvar _globalEvalStyles2 = _interopRequireDefault(_globalEvalStyles);\n\nrequire('../events');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.domData = _domData2.default;\nexports.DomEventEmitterProxy = _DomEventEmitterProxy2.default;\nexports.DomEventHandle = _DomEventHandle2.default;\nexports.features = _features2.default;\nexports.globalEval = _globalEval2.default;\nexports.globalEvalStyles = _globalEvalStyles2.default;\nexports.default = _dom2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/all/dom.js\n// module id = 6\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 7\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nrequire('./incremental-dom');\n\nvar _changes = require('./changes');\n\nvar _data = require('./data');\n\nvar _children = require('./children/children');\n\nvar _patch2 = require('./render/patch');\n\nvar _render = require('./render/render');\n\nvar _metalComponent = require('metal-component');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar IncrementalDomRenderer = function (_ComponentRenderer$co) {\n\t_inherits(IncrementalDomRenderer, _ComponentRenderer$co);\n\n\tfunction IncrementalDomRenderer() {\n\t\t_classCallCheck(this, IncrementalDomRenderer);\n\n\t\treturn _possibleConstructorReturn(this, (IncrementalDomRenderer.__proto__ || Object.getPrototypeOf(IncrementalDomRenderer)).apply(this, arguments));\n\t}\n\n\t_createClass(IncrementalDomRenderer, [{\n\t\tkey: 'buildShouldUpdateArgs',\n\n\t\t/**\n   * Returns an array with the args that should be passed to the component's\n   * `shouldUpdate` method. This can be overridden by sub classes to change\n   * what the method should receive.\n   * @param {Object} changes\n   * @return {!Array}\n   */\n\t\tvalue: function buildShouldUpdateArgs(changes) {\n\t\t\treturn [changes.props];\n\t\t}\n\n\t\t/**\n   * @inheritDoc\n   */\n\n\t}, {\n\t\tkey: 'dispose',\n\t\tvalue: function dispose(component) {\n\t\t\tvar data = (0, _data.getData)(component);\n\t\t\tvar ref = data.config.ref;\n\t\t\tvar owner = data.owner;\n\t\t\tif (owner && owner.components && owner.components[ref] === component) {\n\t\t\t\tdelete owner.components[ref];\n\t\t\t}\n\n\t\t\tif (data.childComponents) {\n\t\t\t\tfor (var i = 0; i < data.childComponents.length; i++) {\n\t\t\t\t\tvar child = data.childComponents[i];\n\t\t\t\t\tif (!child.isDisposed()) {\n\t\t\t\t\t\tchild.element = null;\n\t\t\t\t\t\tchild.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(0, _data.clearData)(component);\n\t\t}\n\n\t\t/**\n   * Generates a key for the element currently being rendered in the given\n   * component. By default, just returns the original key. Sub classes can\n   * override this to change the behavior.\n   * @param {!Component} component\n   * @param {string} key\n   * @return {?string}\n   */\n\n\t}, {\n\t\tkey: 'generateKey',\n\t\tvalue: function generateKey(component, key) {\n\t\t\treturn key;\n\t\t}\n\n\t\t/**\n   * Get the component's config data.\n   * @param {!Component} component\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getConfig',\n\t\tvalue: function getConfig(component) {\n\t\t\treturn (0, _data.getData)(component).config;\n\t\t}\n\n\t\t/**\n   * Get the component's incremental dom renderer data.\n   * @param {!Component} component\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getData',\n\t\tvalue: function getData(component) {\n\t\t\treturn (0, _data.getData)(component);\n\t\t}\n\n\t\t/**\n   * Gets the component that triggered the current patch operation.\n   * @return {Component}\n   */\n\n\t}, {\n\t\tkey: 'getPatchingComponent',\n\t\tvalue: function getPatchingComponent() {\n\t\t\treturn (0, _patch2.getPatchingComponent)();\n\t\t}\n\n\t\t/**\n   * Handles a node having just been rendered. Sub classes should override this\n   * for custom behavior.\n   */\n\n\t}, {\n\t\tkey: 'handleNodeRendered',\n\t\tvalue: function handleNodeRendered() {}\n\n\t\t/**\n   * Checks if the given object is an incremental dom node.\n   * @param {!Object} node\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'isIncDomNode',\n\t\tvalue: function isIncDomNode(node) {\n\t\t\treturn !!(0, _children.getOwner)(node);\n\t\t}\n\n\t\t/**\n   * Calls incremental dom's patch function to render the component.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'patch',\n\t\tvalue: function patch(component) {\n\t\t\t(0, _patch2.patch)(component);\n\t\t}\n\n\t\t/**\n   * Renders the renderer's component for the first time, patching its element\n   * through incremental dom function calls. If the first arg is a function\n   * instead of a component instance, creates and renders this function, which\n   * can either be a simple incremental dom function or a component constructor.\n   * @param {!Component} component\n   * @param {!Component|function()} component Can be a component instance, a\n   *     simple incremental dom function or a component constructor.\n   * @param {Object|Element=} opt_dataOrElement Optional config data for the\n   *     function, or parent for the rendered content.\n   * @param {Element=} opt_parent Optional parent for the rendered content.\n   * @return {!Component} The rendered component's instance.\n   */\n\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(component, opt_dataOrElement, opt_parent) {\n\t\t\tif (component instanceof _metalComponent.Component) {\n\t\t\t\tthis.patch(component);\n\t\t\t} else {\n\t\t\t\treturn (0, _render.renderFunction)(this, component, opt_dataOrElement, opt_parent);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Renders the given child node via its owner renderer.\n   * @param {!Object} child\n   */\n\n\t}, {\n\t\tkey: 'renderChild',\n\t\tvalue: function renderChild(child) {\n\t\t\t(0, _render.renderChild)(child);\n\t\t}\n\n\t\t/**\n   * Calls functions from `IncrementalDOM` to build the component element's\n   * content. Can be overriden by subclasses (for integration with template\n   * engines for example).\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'renderIncDom',\n\t\tvalue: function renderIncDom(component) {\n\t\t\tif (component.render) {\n\t\t\t\tcomponent.render();\n\t\t\t} else {\n\t\t\t\tIncrementalDOM.elementVoid('div');\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Runs the incremental dom functions for rendering this component, without\n   * calling `patch`. This function needs to be called inside a `patch`.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'renderInsidePatch',\n\t\tvalue: function renderInsidePatch(component) {\n\t\t\tvar shouldRender = !component.wasRendered || this.shouldUpdate(component, (0, _changes.getChanges)(component)) || IncrementalDOM.currentPointer() !== component.element;\n\t\t\tif (shouldRender) {\n\t\t\t\t(0, _render.render)(component);\n\t\t\t} else if (component.element) {\n\t\t\t\tthis.skipRender();\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets up this component to be used by this renderer.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'setUp',\n\t\tvalue: function setUp(component) {\n\t\t\tcomponent.context = {};\n\t\t\tcomponent.components = {};\n\t\t\tcomponent.refs = {};\n\n\t\t\tvar data = (0, _data.getData)(component);\n\t\t\tdata.config = component.getInitialConfig();\n\t\t\t(0, _changes.trackChanges)(component);\n\t\t}\n\n\t\t/**\n   * Checks if the component should be updated with the current state changes.\n   * @param {!Component} component\n   * @param {Object} changes\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'shouldUpdate',\n\t\tvalue: function shouldUpdate(component, changes) {\n\t\t\tif (!changes) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (component.shouldUpdate) {\n\t\t\t\treturn component.shouldUpdate.apply(component, _toConsumableArray(this.buildShouldUpdateArgs(changes)));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n   * Skips the next disposal of children components, by clearing the array as\n   * if there were no children rendered the last time. This can be useful for\n   * allowing components to be reused by other parent components in separate\n   * render update cycles.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'skipNextChildrenDisposal',\n\t\tvalue: function skipNextChildrenDisposal(component) {\n\t\t\t(0, _data.getData)(component).childComponents = null;\n\t\t}\n\n\t\t/**\n   * Skips rendering the current node.\n   */\n\n\t}, {\n\t\tkey: 'skipRender',\n\t\tvalue: function skipRender() {\n\t\t\tIncrementalDOM.skipNode();\n\t\t}\n\n\t\t/**\n   * Updates the renderer's component when state changes, patching its element\n   * through incremental dom function calls.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'update',\n\t\tvalue: function update(component) {\n\t\t\tif (this.shouldUpdate(component, (0, _changes.getChanges)(component))) {\n\t\t\t\tthis.patch(component);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn IncrementalDomRenderer;\n}(_metalComponent.ComponentRenderer.constructor);\n\nvar renderer = new IncrementalDomRenderer();\n\n// Name of this renderer. Renderers should provide this as a way to identify\n// them via a simple string (when calling enableCompatibilityMode to add\n// support to old features for specific renderers for example).\nrenderer.RENDERER_NAME = 'incremental-dom';\n\nexports.default = renderer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/IncrementalDomRenderer.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.getOriginalFns = getOriginalFns;\nexports.getOriginalFn = getOriginalFn;\nexports.startInterception = startInterception;\nexports.stopInterception = stopInterception;\n\nrequire('./incremental-dom');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Gets the original incremental dom functions.\n * @return {!Object}\n */\nfunction getOriginalFns() {\n\treturn originalFns;\n}\n\n/**\n * Gets the original incremental dom function with the given name.\n * @param {string} name\n * @return {!Object}\n */\nfunction getOriginalFn(name) {\n\treturn originalFns[name];\n}\n\n/**\n * Starts intercepting calls to incremental dom, replacing them with the given\n * functions. Note that `elementVoid`, `elementOpenStart`, `elementOpenEnd`\n * and `attr` are the only ones that can't be intercepted, since they'll\n * automatically be converted into equivalent calls to `elementOpen` and\n * `elementClose`.\n * @param {!Object} fns Functions to be called instead of the original ones\n *     from incremental DOM. Should be given as a map from the function name\n *     to the function that should intercept it. All interceptors will receive\n *     the original function as the first argument, the actual arguments from\n *     from the original call following it.\n */\nfunction startInterception(fns) {\n\tfns.attr = fnAttr;\n\tfns.elementOpenEnd = fnOpenEnd;\n\tfns.elementOpenStart = fnOpenStart;\n\tfns.elementVoid = fnVoid;\n\tfnStack.push(fns);\n}\n\n/**\n * Restores the original `elementOpen` function from incremental dom to the\n * implementation it used before the last call to `startInterception`.\n */\nfunction stopInterception() {\n\tfnStack.pop();\n}\n\nvar originalFns = {\n\tattr: IncrementalDOM.attr,\n\tattributes: IncrementalDOM.attributes[IncrementalDOM.symbols.default],\n\telementClose: IncrementalDOM.elementClose,\n\telementOpen: IncrementalDOM.elementOpen,\n\telementOpenEnd: IncrementalDOM.elementOpenEnd,\n\telementOpenStart: IncrementalDOM.elementOpenStart,\n\telementVoid: IncrementalDOM.elementVoid,\n\ttext: IncrementalDOM.text\n};\n\nvar fnStack = [];\n\nvar collectedArgs = [];\n\nfunction fnAttr(name, value) {\n\tcollectedArgs.push(name, value);\n}\n\nfunction fnOpenStart(tag, key, statics) {\n\tcollectedArgs = [tag, key, statics];\n}\n\nfunction fnOpenEnd() {\n\tvar _IncrementalDOM;\n\n\treturn (_IncrementalDOM = IncrementalDOM).elementOpen.apply(_IncrementalDOM, _toConsumableArray(collectedArgs));\n}\n\nfunction fnVoid() {\n\tIncrementalDOM.elementOpen.apply(null, arguments);\n\treturn IncrementalDOM.elementClose.apply(null, arguments);\n}\n\nfunction getStack() {\n\treturn fnStack.length > 0 ? fnStack[fnStack.length - 1] : null;\n}\n\nfunction buildHandleCall(name) {\n\tvar data = {\n\t\tname: name\n\t};\n\tvar fn = handleCall.bind(data);\n\treturn fn;\n}\n\nfunction handleCall() {\n\tvar name = this.name; // eslint-disable-line\n\tvar stack = getStack();\n\tvar fn = stack && stack[name] || originalFns[name];\n\treturn fn.apply(null, arguments);\n}\n\nIncrementalDOM.attr = buildHandleCall('attr');\nIncrementalDOM.elementClose = buildHandleCall('elementClose');\nIncrementalDOM.elementOpen = buildHandleCall('elementOpen');\nIncrementalDOM.elementOpenEnd = buildHandleCall('elementOpenEnd');\nIncrementalDOM.elementOpenStart = buildHandleCall('elementOpenStart');\nIncrementalDOM.elementVoid = buildHandleCall('elementVoid');\nIncrementalDOM.text = buildHandleCall('text');\n\nIncrementalDOM.attributes[IncrementalDOM.symbols.default] = buildHandleCall('attributes');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/incremental-dom-aop.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar METAL_DATA = '__metal_data__';\n\nvar domData = function () {\n\tfunction domData() {\n\t\t_classCallCheck(this, domData);\n\t}\n\n\t_createClass(domData, null, [{\n\t\tkey: 'get',\n\n\t\t/**\n   * Gets Metal.js's data for the given element.\n   * @param {!Element} element\n   * @param {string=} opt_name Optional property from the data to be returned.\n   * @param {*} opt_initialVal Optinal value to the set the requested property\n   *     to if it doesn't exist yet in the data.\n   * @return {!Object}\n   */\n\t\tvalue: function get(element, opt_name, opt_initialVal) {\n\t\t\tif (!element[METAL_DATA]) {\n\t\t\t\telement[METAL_DATA] = {};\n\t\t\t}\n\t\t\tif (!opt_name) {\n\t\t\t\treturn element[METAL_DATA];\n\t\t\t}\n\t\t\tif (!element[METAL_DATA][opt_name] && opt_initialVal) {\n\t\t\t\telement[METAL_DATA][opt_name] = opt_initialVal;\n\t\t\t}\n\t\t\treturn element[METAL_DATA][opt_name];\n\t\t}\n\n\t\t/**\n   * Checks if the given element has data stored in it.\n   * @param {!Element} element\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'has',\n\t\tvalue: function has(element) {\n\t\t\treturn !!element[METAL_DATA];\n\t\t}\n\t}]);\n\n\treturn domData;\n}();\n\nexports.default = domData;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/domData.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _metal = require('metal');\n\nvar ERROR_ARRAY_OF_TYPE = 'Expected an array of single type.';\nvar ERROR_OBJECT_OF_TYPE = 'Expected object of one type.';\nvar ERROR_ONE_OF = 'Expected one of given values.';\nvar ERROR_ONE_OF_TYPE = 'Expected one of given types.';\nvar ERROR_SHAPE_OF = 'Expected object with a specific shape.';\n\n/**\n * Provides access to various type validators that will return an\n * instance of Error when validation fails. Note that all type validators\n * will also accept null or undefined values. To not accept these you should\n * instead make your state property required.\n */\nvar validators = {\n\tany: function any() {\n\t\treturn function () {\n\t\t\treturn true;\n\t\t};\n\t},\n\tarray: buildTypeValidator('array'),\n\tbool: buildTypeValidator('boolean'),\n\tfunc: buildTypeValidator('function'),\n\tnumber: buildTypeValidator('number'),\n\tobject: buildTypeValidator('object'),\n\tstring: buildTypeValidator('string'),\n\n\t/**\n  * Creates a validator that checks that the value it receives is an array\n  * of items, and that all of the items pass the given validator.\n  * @param {!function()} validator Validator to check each item against.\n  * @return {!function()}\n  */\n\tarrayOf: function arrayOf(validator) {\n\t\treturn maybe(function (value, name, context) {\n\t\t\tvar result = validators.array(value, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn validateArrayItems(validator, value, name, context);\n\t\t});\n\t},\n\n\t/**\n  * Creates a validator that checks if a value is an instance of a given class.\n  * @param {!function()} expectedClass Class to check value against.\n  * @return {!function()}\n  */\n\tinstanceOf: function instanceOf(expectedClass) {\n\t\treturn maybe(function (value, name, context) {\n\t\t\tif (value instanceof expectedClass) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar msg = 'Expected instance of ' + expectedClass;\n\t\t\treturn composeError(msg, name, context);\n\t\t});\n\t},\n\n\t/**\n  * Creates a validator that checks that the value it receives is an object,\n  * and that all values within that object pass the given validator.\n  * @param {!function()} validator Validator to check each object value against.\n  * @return {!function()}\n  */\n\tobjectOf: function objectOf(validator) {\n\t\treturn maybe(function (value, name, context) {\n\t\t\tfor (var key in value) {\n\t\t\t\tif (isInvalid(validator(value[key]))) {\n\t\t\t\t\treturn composeError(ERROR_OBJECT_OF_TYPE, name, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t},\n\n\t/**\n  * Creates a validator that checks if the received value matches one of the\n  * given values.\n  * @param {!Array} arrayOfValues Array of values to check equality against.\n  * @return {!function()}\n  */\n\toneOf: function oneOf(arrayOfValues) {\n\t\treturn maybe(function (value, name, context) {\n\t\t\tvar result = validators.array(arrayOfValues, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn arrayOfValues.indexOf(value) === -1 ? composeError(ERROR_ONE_OF, name, context) : true;\n\t\t});\n\t},\n\n\t/**\n  * Creates a validator that checks if the received value matches one of the\n  * given types.\n  * @param {!Array} arrayOfTypeValidators Array of validators to check value\n  *     against.\n  * @return {!function()}\n  */\n\toneOfType: function oneOfType(arrayOfTypeValidators) {\n\t\treturn maybe(function (value, name, context) {\n\t\t\tvar result = validators.array(arrayOfTypeValidators, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < arrayOfTypeValidators.length; i++) {\n\t\t\t\tif (!isInvalid(arrayOfTypeValidators[i](value, name, context))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn composeError(ERROR_ONE_OF_TYPE, name, context);\n\t\t});\n\t},\n\n\t/**\n  * Creates a validator that checks if the received value is an object, and\n  * that its contents match the given shape.\n  * @param {!Object} shape An object containing validators for each key.\n  * @return {!function()}\n  */\n\tshapeOf: function shapeOf(shape) {\n\t\treturn maybe(function (value, name, context) {\n\t\t\tvar result = validators.object(shape, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (var key in shape) {\n\t\t\t\tvar validator = shape[key];\n\t\t\t\tvar required = false;\n\t\t\t\tif (validator.config) {\n\t\t\t\t\trequired = validator.config.required;\n\t\t\t\t\tvalidator = validator.config.validator;\n\t\t\t\t}\n\t\t\t\tif (required && !(0, _metal.isDefAndNotNull)(value[key]) || isInvalid(validator(value[key]))) {\n\t\t\t\t\treturn composeError(ERROR_SHAPE_OF, name, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n};\n\n/**\n * Creates a validator that checks against a specific primitive type.\n * @param {string} expectedType Type to check against.\n * @return {!function()} Function that runs the validator if called with\n *     arguments, or just returns it otherwise. This means that when using a\n *     type validator in `State` it may be just passed directly (like\n *     `validators.bool`), or called with no args (like `validators.bool()`).\n *     That's done to allow all validators to be used consistently, since some\n *     (like `arrayOf`) always require that you call the function before\n *     receiving the actual validator. Type validators don't need the call, but\n *     work if it's made anyway.\n */\nfunction buildTypeValidator(expectedType) {\n\tvar validatorFn = maybe(validateType.bind(null, expectedType));\n\treturn function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn validatorFn;\n\t\t} else {\n\t\t\treturn validatorFn.apply(undefined, arguments);\n\t\t}\n\t};\n}\n\n/**\n * Composes a warning a warning message.\n * @param {string} error Error message to display to console.\n * @param {?string} name Name of state property that is giving the error.\n * @param {Object} context The property's owner.\n * @return {!Error}\n */\nfunction composeError(error, name, context) {\n\tvar compName = context ? (0, _metal.getFunctionName)(context.constructor) : null;\n\tvar renderer = context && context.getRenderer && context.getRenderer();\n\tvar parent = renderer && renderer.getParent && renderer.getParent();\n\tvar parentName = parent ? (0, _metal.getFunctionName)(parent.constructor) : null;\n\tvar location = parentName ? 'Check render method of \\'' + parentName + '\\'.' : '';\n\treturn new Error('Warning: Invalid state passed to \\'' + name + '\\'. ' + (error + ' Passed to \\'' + compName + '\\'. ' + location));\n}\n\n/**\n * Returns the type of the given value.\n * @param {*} value Any value.\n * @return {string} Type of value.\n */\nfunction getType(value) {\n\treturn Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : _typeof(value);\n}\n\n/**\n * Checks if the given validator result says that the value is invalid.\n * @param {boolean|!Error} result\n * @return {boolean}\n */\nfunction isInvalid(result) {\n\treturn result instanceof Error;\n}\n\n/**\n * Wraps the given validator so that it also accepts null/undefined values.\n *   a validator that checks a value against a single type, null, or\n * undefined.\n * @param {!function()} typeValidator Validator to wrap.\n * @return {!function()} Wrapped validator.\n */\nfunction maybe(typeValidator) {\n\treturn function (value, name, context) {\n\t\treturn (0, _metal.isDefAndNotNull)(value) ? typeValidator(value, name, context) : true;\n\t};\n}\n\n/**\n * Checks if all the items of the given array pass the given validator.\n * @param {!function()} validator\n * @param {*} value The array to validate items for.\n * @param {string} name The name of the array property being checked.\n * @param {!Object} context Owner of the array property being checked.\n * @return {!Error|boolean} `true` if the type matches, or an error otherwise.\n */\nfunction validateArrayItems(validator, value, name, context) {\n\tfor (var i = 0; i < value.length; i++) {\n\t\tif (isInvalid(validator(value[i], name, context))) {\n\t\t\treturn composeError(ERROR_ARRAY_OF_TYPE, name, context);\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Checks if the given value matches the expected type.\n * @param {string} expectedType String representing the expected type.\n * @param {*} value The value to match the type of.\n * @param {string} name The name of the property being checked.\n * @param {!Object} context Owner of the property being checked.\n * @return {!Error|boolean} `true` if the type matches, or an error otherwise.\n */\nfunction validateType(expectedType, value, name, context) {\n\tvar type = getType(value);\n\tif (type !== expectedType) {\n\t\tvar msg = 'Expected type \\'' + expectedType + '\\', but received type \\'' + type + '\\'.';\n\t\treturn composeError(msg, name, context);\n\t}\n\treturn true;\n}\n\nexports.default = validators;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-state/lib/validators.js\n// module id = 12\n// module chunks = 0","'use strict';\n\n// This file exists just for backwards compatibility, making sure that old\n// default imports for this file still work. It's best to use the named exports\n// for each function instead though, since that allows bundlers like Rollup to\n// reduce the bundle size by removing unused code.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.core = undefined;\n\nvar _coreNamed = require('./coreNamed');\n\nObject.keys(_coreNamed).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _coreNamed[key];\n    }\n  });\n});\n\nvar core = _interopRequireWildcard(_coreNamed);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.default = core;\nexports.core = core;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/core.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * EventHandle utility. Holds information about an event subscription, and\n * allows removing them easily.\n * EventHandle is a Disposable, but it's important to note that the\n * EventEmitter that created it is not the one responsible for disposing it.\n * That responsibility is for the code that holds a reference to it.\n * @param {!EventEmitter} emitter Emitter the event was subscribed to.\n * @param {string} event The name of the event that was subscribed to.\n * @param {!Function} listener The listener subscribed to the event.\n * @constructor\n * @extends {Disposable}\n */\nvar EventHandle = function (_Disposable) {\n\t_inherits(EventHandle, _Disposable);\n\n\tfunction EventHandle(emitter, event, listener) {\n\t\t_classCallCheck(this, EventHandle);\n\n\t\t/**\n   * The EventEmitter instance that the event was subscribed to.\n   * @type {EventEmitter}\n   * @protected\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (EventHandle.__proto__ || Object.getPrototypeOf(EventHandle)).call(this));\n\n\t\t_this.emitter_ = emitter;\n\n\t\t/**\n   * The name of the event that was subscribed to.\n   * @type {string}\n   * @protected\n   */\n\t\t_this.event_ = event;\n\n\t\t/**\n   * The listener subscribed to the event.\n   * @type {Function}\n   * @protected\n   */\n\t\t_this.listener_ = listener;\n\t\treturn _this;\n\t}\n\n\t/**\n  * Disposes of this instance's object references.\n  * @override\n  */\n\n\n\t_createClass(EventHandle, [{\n\t\tkey: 'disposeInternal',\n\t\tvalue: function disposeInternal() {\n\t\t\tthis.removeListener();\n\t\t\tthis.emitter_ = null;\n\t\t\tthis.listener_ = null;\n\t\t}\n\n\t\t/**\n   * Removes the listener subscription from the emitter.\n   */\n\n\t}, {\n\t\tkey: 'removeListener',\n\t\tvalue: function removeListener() {\n\t\t\tif (!this.emitter_.isDisposed()) {\n\t\t\t\tthis.emitter_.removeListener(this.event_, this.listener_);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn EventHandle;\n}(_metal.Disposable);\n\nexports.default = EventHandle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-events/lib/EventHandle.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nrequire('./iDOMHelpers');\n\nvar _metal = require('metal');\n\nvar _metalComponent = require('metal-component');\n\nvar _metalComponent2 = _interopRequireDefault(_metalComponent);\n\nvar _metalIncrementalDom = require('metal-incremental-dom');\n\nvar _metalIncrementalDom2 = _interopRequireDefault(_metalIncrementalDom);\n\nvar _JSXDataManager = require('./JSXDataManager');\n\nvar _JSXDataManager2 = _interopRequireDefault(_JSXDataManager);\n\nvar _JSXRenderer = require('./JSXRenderer');\n\nvar _JSXRenderer2 = _interopRequireDefault(_JSXRenderer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * A component that has built-in integration with JSX templates. Example:\n *\n * <code>\n * class MyComponent extends JSXComponent {\n *   render() {\n *     return <div>Hello World</div>\n *   }\n * }\n * </code>\n */\nvar JSXComponent = function (_Component) {\n\t_inherits(JSXComponent, _Component);\n\n\tfunction JSXComponent() {\n\t\t_classCallCheck(this, JSXComponent);\n\n\t\treturn _possibleConstructorReturn(this, (JSXComponent.__proto__ || Object.getPrototypeOf(JSXComponent)).apply(this, arguments));\n\t}\n\n\t_createClass(JSXComponent, [{\n\t\tkey: 'otherProps',\n\n\n\t\t/**\n   * Returns props that are not used or declared in the component.\n   * @return {Object} Object containing props\n   */\n\t\tvalue: function otherProps() {\n\t\t\tvar removeKeys = [].concat(_toConsumableArray(this.getDataManager().getPropsInstance(this).getStateKeys()), ['key', 'ref']);\n\n\t\t\tvar retObj = _metal.object.mixin({}, this.props);\n\n\t\t\tfor (var i = 0; i < removeKeys.length; i++) {\n\t\t\t\tvar key = removeKeys[i];\n\n\t\t\t\tif (retObj.hasOwnProperty(key)) {\n\t\t\t\t\tdelete retObj[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn retObj;\n\t\t}\n\t}], [{\n\t\tkey: 'render',\n\n\t\t/**\n   * Creates and renders the given function, which can either be a simple\n   * JSX function or a component constructor.\n   * @param {!function()} fnOrCtor Either be a simple jsx dom function or a\n   *     component constructor.\n   * @param {Object=} opt_data Optional config data for the function.\n   * @param {Element=} opt_element Optional parent for the rendered content.\n   * @return {!Component} The rendered component's instance.\n   * @override\n   */\n\t\tvalue: function render() {\n\t\t\treturn _metalIncrementalDom2.default.render.apply(_metalIncrementalDom2.default, arguments);\n\t\t}\n\t}]);\n\n\treturn JSXComponent;\n}(_metalComponent2.default);\n\nJSXComponent.DATA_MANAGER = _JSXDataManager2.default;\nJSXComponent.RENDERER = _JSXRenderer2.default;\n\nexports.default = JSXComponent;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-jsx/lib/JSXComponent.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nvar _incrementalDom = require('incremental-dom');\n\nvar IncrementalDOM = _interopRequireWildcard(_incrementalDom);\n\nvar _incrementalDomString = require('incremental-dom-string');\n\nvar IncrementalDOMString = _interopRequireWildcard(_incrementalDomString);\n\nvar _metal = require('metal');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nif ((0, _metal.isServerSide)()) {\n\t// Overrides global.IncrementalDOM virtual elements with incremental dom\n\t// string implementation for server side rendering. At the moment it does not\n\t// override for Node.js tests since tests are using jsdom to simulate the\n\t// browser.\n\tglobal.IncrementalDOM = IncrementalDOMString;\n} else {\n\tvar scope = typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window;\n\n\tscope.IncrementalDOM = IncrementalDOM;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/incremental-dom.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearChanges = clearChanges;\nexports.getChanges = getChanges;\nexports.trackChanges = trackChanges;\n\nvar _data = require('./data');\n\n/**\n * Clears the changes tracked so far.\n * @param {!Object} data\n */\nfunction clearChanges(data) {\n  data.changes = null;\n}\n\n/**\n * Handles the `stateKeyChanged` event from a component. Stores change data.\n * @param {!Object} data\n * @param {!Object} eventData\n * @private\n */\nfunction handleStateKeyChanged_(data, eventData) {\n  data.changes = data.changes || {};\n  var type = eventData.type || 'props';\n  data.changes[type] = data.changes[type] || {};\n  data.changes[type][eventData.key] = eventData;\n}\n\n/**\n * Returns an object with changes in the given component since the last time,\n * or null if there weren't any.\n * @param {!Component} component\n * @return {Object}\n */\nfunction getChanges(component) {\n  return (0, _data.getData)(component).changes;\n}\n\n/**\n * Starts tracking changes for the given component\n * @param {!Component} component\n */\nfunction trackChanges(component) {\n  var data = (0, _data.getData)(component);\n  component.on('stateKeyChanged', handleStateKeyChanged_.bind(null, data));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/changes.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.CHILD_OWNER = undefined;\nexports.captureChildren = captureChildren;\nexports.isChildTag = isChildTag;\nexports.getOwner = getOwner;\nexports.renderChildTree = renderChildTree;\n\nvar _callArgs = require('../callArgs');\n\nvar _metal = require('metal');\n\nvar _incrementalDomAop = require('../incremental-dom-aop');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Property identifying a specific object as a Metal.js child node, and\n * pointing to the component instance that created it.\n * @type {string}\n */\nvar CHILD_OWNER = exports.CHILD_OWNER = '__metalChildOwner';\n\n/**\n * Captures all child elements from incremental dom calls.\n * @param {!Component} component The component that is capturing children.\n * @param {!function()} callback Function to be called when children have all\n *     been captured.\n * @param {Object} data Data to pass to the callback function when calling it.\n */\nfunction captureChildren(component, callback, data) {\n\towner_ = component;\n\tcallback_ = callback;\n\tcallbackData_ = data;\n\ttree_ = {\n\t\tprops: {\n\t\t\tchildren: []\n\t\t}\n\t};\n\ttree_.config = tree_.props;\n\tcurrentParent_ = tree_;\n\tisCapturing_ = true;\n\t(0, _incrementalDomAop.startInterception)({\n\t\telementClose: handleInterceptedCloseCall_,\n\t\telementOpen: handleInterceptedOpenCall_,\n\t\ttext: handleInterceptedTextCall_\n\t});\n}\n\n/**\n * Checks if the given tag was built from a component's children.\n * @param {*} tag\n * @return {boolean}\n */\nfunction isChildTag(tag) {\n\treturn (0, _metal.isDef)(tag.tag);\n}\n\n/**\n * Gets the node's original owner.\n * @param {!Object} node\n * @return {Component}\n */\nfunction getOwner(node) {\n\treturn node[CHILD_OWNER];\n}\n\n/**\n * Renders a children tree through incremental dom.\n * @param {!{args: Array, children: !Array, isText: ?boolean}}\n * @param {function()=} opt_skipNode Optional function that is called for\n *     each node to be rendered. If it returns true, the node will be skipped.\n * @protected\n */\nfunction renderChildTree(tree, opt_skipNode) {\n\tif (isCapturing_) {\n\t\t// If capturing, just add the node directly to the captured tree.\n\t\taddChildToTree(tree);\n\t\treturn;\n\t}\n\n\tif (opt_skipNode && opt_skipNode.call(null, tree)) {\n\t\treturn;\n\t}\n\n\tif ((0, _metal.isDef)(tree.text)) {\n\t\tvar args = tree.args ? tree.args : [];\n\t\targs[0] = tree.text;\n\t\tIncrementalDOM.text.apply(null, args);\n\t} else {\n\t\tvar _args = (0, _callArgs.buildCallFromConfig)(tree.tag, tree.props);\n\t\t_args[0] = {\n\t\t\ttag: _args[0],\n\t\t\towner: getOwner(tree)\n\t\t};\n\t\tIncrementalDOM.elementOpen.apply(null, _args);\n\t\tif (tree.props.children) {\n\t\t\tfor (var i = 0; i < tree.props.children.length; i++) {\n\t\t\t\trenderChildTree(tree.props.children[i], opt_skipNode);\n\t\t\t}\n\t\t}\n\t\tIncrementalDOM.elementClose(tree.tag);\n\t}\n}\n\nvar callbackData_ = void 0;\nvar callback_ = void 0;\nvar currentParent_ = void 0;\nvar isCapturing_ = false;\nvar owner_ = void 0;\nvar tree_ = void 0;\n\n/**\n * Adds a child element to the tree.\n * @param {!Array} args The arguments passed to the incremental dom call.\n * @param {boolean=} opt_isText Optional flag indicating if the child is a\n *     text element.\n * @protected\n */\nfunction addChildCallToTree_(args, opt_isText) {\n\tvar child = _defineProperty({\n\t\tparent: currentParent_\n\t}, CHILD_OWNER, owner_);\n\n\tif (opt_isText) {\n\t\tchild.text = args[0];\n\t\tif (args.length > 1) {\n\t\t\tchild.args = args;\n\t\t}\n\t} else {\n\t\tchild.tag = args[0];\n\t\tchild.props = (0, _callArgs.buildConfigFromCall)(args);\n\t\tchild.props.children = [];\n\t\tchild.config = child.props;\n\t}\n\n\taddChildToTree(child);\n\treturn child;\n}\n\nfunction addChildToTree(child) {\n\tcurrentParent_.props.children.push(child);\n}\n\n/**\n * Handles an intercepted call to the `elementClose` function from incremental\n * dom.\n * @protected\n */\nfunction handleInterceptedCloseCall_() {\n\tif (currentParent_ === tree_) {\n\t\t(0, _incrementalDomAop.stopInterception)();\n\t\tisCapturing_ = false;\n\t\tvar node = callback_.call(owner_, tree_, callbackData_);\n\t\tcallback_ = null;\n\t\tcallbackData_ = null;\n\t\tcurrentParent_ = null;\n\t\towner_ = null;\n\t\ttree_ = null;\n\t\treturn node;\n\t} else {\n\t\tcurrentParent_ = currentParent_.parent;\n\t\treturn true;\n\t}\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom.\n * @param {!function()} originalFn The original function before interception.\n * @protected\n */\nfunction handleInterceptedOpenCall_() {\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\tcurrentParent_ = addChildCallToTree_(args);\n}\n\n/**\n * Handles an intercepted call to the `text` function from incremental dom.\n * @param {!function()} originalFn The original function before interception.\n * @protected\n */\nfunction handleInterceptedTextCall_() {\n\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\targs[_key2] = arguments[_key2];\n\t}\n\n\taddChildCallToTree_(args, true);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/children/children.js\n// module id = 18\n// module chunks = 0","'use strict';\n\n/**\n * Builds the component config object from its incremental dom call's\n * arguments.\n * @param {!Array} args\n * @return {!Object}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.buildConfigFromCall = buildConfigFromCall;\nexports.buildCallFromConfig = buildCallFromConfig;\nfunction buildConfigFromCall(args) {\n\tvar config = {};\n\tif (args[1]) {\n\t\tconfig.key = args[1];\n\t}\n\tvar attrsArr = (args[2] || []).concat(args.slice(3));\n\tfor (var i = 0; i < attrsArr.length; i += 2) {\n\t\tconfig[attrsArr[i]] = attrsArr[i + 1];\n\t}\n\treturn config;\n}\n\n/**\n * Builds an incremental dom call array from the given tag and config object.\n * @param {string} tag\n * @param {!Object} config\n * @return {!Array}\n */\nfunction buildCallFromConfig(tag, config) {\n\tvar call = [tag, config.key, []];\n\tvar keys = Object.keys(config);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (keys[i] !== 'children' && keys[i] !== 'key') {\n\t\t\tcall.push(keys[i], config[keys[i]]);\n\t\t}\n\t}\n\treturn call;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/callArgs.js\n// module id = 19\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metalEvents = require('metal-events');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * This is a special EventHandle, that is responsible for dom events, instead\n * of EventEmitter events.\n * @extends {EventHandle}\n */\nvar DomEventHandle = function (_EventHandle) {\n\t_inherits(DomEventHandle, _EventHandle);\n\n\t/**\n  * The constructor for `DomEventHandle`.\n  * @param {!EventEmitter} emitter Emitter the event was subscribed to.\n  * @param {string} event The name of the event that was subscribed to.\n  * @param {!Function} listener The listener subscribed to the event.\n  * @param {boolean} opt_capture Flag indicating if listener should be triggered\n  *   during capture phase, instead of during the bubbling phase. Defaults to false.\n  * @constructor\n  */\n\tfunction DomEventHandle(emitter, event, listener, opt_capture) {\n\t\t_classCallCheck(this, DomEventHandle);\n\n\t\tvar _this = _possibleConstructorReturn(this, (DomEventHandle.__proto__ || Object.getPrototypeOf(DomEventHandle)).call(this, emitter, event, listener));\n\n\t\t_this.capture_ = opt_capture;\n\t\treturn _this;\n\t}\n\n\t/**\n  * @inheritDoc\n  */\n\n\n\t_createClass(DomEventHandle, [{\n\t\tkey: 'removeListener',\n\t\tvalue: function removeListener() {\n\t\t\tthis.emitter_.removeEventListener(this.event_, this.listener_, this.capture_);\n\t\t}\n\t}]);\n\n\treturn DomEventHandle;\n}(_metalEvents.EventHandle);\n\nexports.default = DomEventHandle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/DomEventHandle.js\n// module id = 20\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _dom = require('./dom');\n\nvar _metal = require('metal');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Class with static methods responsible for doing browser feature checks.\n */\nvar features = function () {\n\tfunction features() {\n\t\t_classCallCheck(this, features);\n\t}\n\n\t_createClass(features, null, [{\n\t\tkey: 'checkAnimationEventName',\n\n\t\t/**\n   * Some browsers still supports prefixed animation events. This method can\n   * be used to retrieve the current browser event name for both, animation\n   * and transition.\n   * @return {object}\n   */\n\t\tvalue: function checkAnimationEventName() {\n\t\t\tif (features.animationEventName_ === undefined) {\n\t\t\t\tfeatures.animationEventName_ = {\n\t\t\t\t\tanimation: features.checkAnimationEventName_('animation'),\n\t\t\t\t\ttransition: features.checkAnimationEventName_('transition')\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn features.animationEventName_;\n\t\t}\n\n\t\t/**\n   * @protected\n   * @param {string} type Type to test: animation, transition.\n   * @return {string} Browser event name.\n   */\n\n\t}, {\n\t\tkey: 'checkAnimationEventName_',\n\t\tvalue: function checkAnimationEventName_(type) {\n\t\t\tvar prefixes = ['Webkit', 'MS', 'O', ''];\n\t\t\tvar typeTitleCase = _metal.string.replaceInterval(type, 0, 1, type.substring(0, 1).toUpperCase());\n\t\t\tvar suffixes = [typeTitleCase + 'End', typeTitleCase + 'End', typeTitleCase + 'End', type + 'end'];\n\t\t\tfor (var i = 0; i < prefixes.length; i++) {\n\t\t\t\tif (features.animationElement_.style[prefixes[i] + typeTitleCase] !== undefined) {\n\t\t\t\t\treturn prefixes[i].toLowerCase() + suffixes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn type + 'end';\n\t\t}\n\n\t\t/**\n   * Some browsers (like IE9) change the order of element attributes, when html\n   * is rendered. This method can be used to check if this behavior happens on\n   * the current browser.\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'checkAttrOrderChange',\n\t\tvalue: function checkAttrOrderChange() {\n\t\t\tif (features.attrOrderChange_ === undefined) {\n\t\t\t\tvar originalContent = '<div data-component=\"\" data-ref=\"\"></div>';\n\t\t\t\tvar element = document.createElement('div');\n\t\t\t\t(0, _dom.append)(element, originalContent);\n\t\t\t\tfeatures.attrOrderChange_ = originalContent !== element.innerHTML;\n\t\t\t}\n\t\t\treturn features.attrOrderChange_;\n\t\t}\n\t}]);\n\n\treturn features;\n}();\n\nfeatures.animationElement_ = document.createElement('div');\nfeatures.animationEventName_ = undefined;\nfeatures.attrOrderChange_ = undefined;\n\nexports.default = features;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/features.js\n// module id = 21\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.getComponentBeingRendered = getComponentBeingRendered;\nexports.isComponentTag_ = isComponentTag_;\nexports.render = render;\nexports.renderChild = renderChild;\nexports.renderFunction = renderFunction;\n\nvar _attributes = require('./attributes');\n\nvar _callArgs = require('../callArgs');\n\nvar _children = require('../children/children');\n\nvar _changes = require('../changes');\n\nvar _metalDom = require('metal-dom');\n\nvar _data = require('../data');\n\nvar _metal = require('metal');\n\nvar _unused = require('../cleanup/unused');\n\nvar _incrementalDomAop = require('../incremental-dom-aop');\n\nvar _metalComponent = require('metal-component');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar renderingComponents_ = [];\nvar emptyChildren_ = [];\n\n/**\n * Adds the given css classes to the specified arguments for an incremental\n * dom call, merging with the existing value if there is one.\n * @param {string} elementClasses\n * @param {!Object} config\n * @private\n */\nfunction addElementClasses_(elementClasses, config) {\n\tif (config.class) {\n\t\tconfig.class += ' ' + elementClasses;\n\t\tconfig.class = removeDuplicateClasses_(config.class);\n\t} else {\n\t\tconfig.class = elementClasses;\n\t}\n}\n\n/**\n * Builds the \"children\" array to be passed to the current component.\n * @param {!Array<!Object>} children\n * @return {!Array<!Object>}\n * @private\n */\nfunction buildChildren_(children) {\n\treturn children.length === 0 ? emptyChildren_ : children;\n}\n\n/**\n * Finishes the render operation, doing some cleaups.\n * @param {!Component} component\n * @private\n */\nfunction cleanUpRender_(component) {\n\t(0, _incrementalDomAop.stopInterception)();\n\tif (!(0, _data.getData)(component).rootElementReached) {\n\t\tcomponent.element = null;\n\t}\n\tcomponent.informRendered();\n\tfinishedRenderingComponent_();\n}\n\n/**\n * Removes the most recent component from the queue of rendering components.\n * @private\n */\nfunction finishedRenderingComponent_() {\n\trenderingComponents_.pop();\n\tif (renderingComponents_.length === 0) {\n\t\t(0, _unused.disposeUnused)();\n\t}\n}\n\n/**\n * Generates a key for the next element to be rendered.\n * @param {!Component} component\n * @param {?string} key The key originally passed to the element.\n * @return {?string}\n * @private\n */\nfunction generateKey_(component, key) {\n\tvar data = (0, _data.getData)(component);\n\tif (!data.rootElementReached && data.config.key) {\n\t\tkey = data.config.key;\n\t}\n\treturn component.getRenderer().generateKey(component, key);\n}\n\n/**\n * Gets the child components stored in the given object.\n * @param {!Object} data\n * @return {!Array<!Component>}\n * @private\n */\nfunction getChildComponents_(data) {\n\tdata.childComponents = data.childComponents || [];\n\treturn data.childComponents;\n}\n\n/**\n * Gets the component being currently rendered.\n * @return {Component}\n */\nfunction getComponentBeingRendered() {\n\treturn renderingComponents_[renderingComponents_.length - 1];\n}\n\n/**\n * Gets the data object that should be currently used. This object will either\n * come from the current element being rendered by incremental dom or from\n * the component instance being rendered (only when the current element is the\n * component's direct parent).\n * @return {!Object}\n * @private\n */\nfunction getCurrentData() {\n\tvar element = IncrementalDOM.currentElement();\n\tvar comp = getComponentBeingRendered();\n\tvar obj = (0, _data.getData)(comp);\n\tif (obj.rootElementReached && element !== comp.element.parentNode) {\n\t\tobj = _metalDom.domData.get(element);\n\t}\n\tobj.icComponentsData = obj.icComponentsData || {};\n\treturn obj.icComponentsData;\n}\n\n/**\n * Returns the \"ref\" to be used for a component. Uses \"key\" as \"ref\" when\n * compatibility mode is on for the current renderer.\n * @param {!Component} owner\n * @param {!Object} config\n * @return {?string}\n * @private\n */\nfunction getRef_(owner, config) {\n\tvar compatData = (0, _metal.getCompatibilityModeData)();\n\tif (compatData) {\n\t\tvar ownerRenderer = owner.getRenderer();\n\t\tvar renderers = compatData.renderers;\n\t\tvar useKey = !renderers || renderers.indexOf(ownerRenderer) !== -1 || renderers.indexOf(ownerRenderer.RENDERER_NAME) !== -1;\n\t\tif (useKey && config.key && !config.ref) {\n\t\t\treturn config.key;\n\t\t}\n\t}\n\treturn config.ref;\n}\n\n/**\n * Gets the sub component referenced by the given tag and config data,\n * creating it if it doesn't yet exist.\n * @param {string|!Function} tagOrCtor The tag name.\n * @param {!Object} config The config object for the sub component.\n * @param {!Component} owner\n * @return {!Component} The sub component.\n * @protected\n */\nfunction getSubComponent_(tagOrCtor, config, owner) {\n\tvar Ctor = tagOrCtor;\n\tif ((0, _metal.isString)(Ctor)) {\n\t\tCtor = _metalComponent.ComponentRegistry.getConstructor(tagOrCtor);\n\t}\n\n\tvar ref = getRef_(owner, config);\n\tvar comp = void 0;\n\tif ((0, _metal.isDef)(ref)) {\n\t\tcomp = match_(owner.components[ref], Ctor, config, owner);\n\t\towner.components[ref] = comp;\n\t\towner.refs[ref] = comp;\n\t} else {\n\t\tvar data = getCurrentData();\n\t\tvar key = config.key;\n\t\tif (!(0, _metal.isDef)(key)) {\n\t\t\tvar type = (0, _metal.getUid)(Ctor, true);\n\t\t\tdata.currCount = data.currCount || {};\n\t\t\tdata.currCount[type] = data.currCount[type] || 0;\n\t\t\tkey = '__METAL_IC__' + type + '_' + data.currCount[type]++;\n\t\t}\n\t\tcomp = match_(data.prevComps ? data.prevComps[key] : null, Ctor, config, owner);\n\t\tdata.currComps = data.currComps || {};\n\t\tdata.currComps[key] = comp;\n\t}\n\n\treturn comp;\n}\n\n/**\n * Handles the event of children having finished being captured.\n * @param {!Object} tree The captured children in tree format.\n * @private\n */\nfunction handleChildrenCaptured_(tree, _ref) {\n\tvar props = _ref.props,\n\t    tag = _ref.tag;\n\n\tprops.children = buildChildren_(tree.props.children);\n\treturn renderFromTag_(tag, props);\n}\n\n/**\n * Handles a child being rendered via `IncrementalDomChildren.render`. Skips\n * component nodes so that they can be rendered the correct way without\n * having to recapture both them and their children via incremental dom.\n * @param {!Object} node\n * @return {boolean}\n * @private\n */\nfunction handleChildRender_(node) {\n\tif (node.tag && isComponentTag_(node.tag)) {\n\t\tnode.props.children = buildChildren_(node.props.children);\n\t\trenderFromTag_(node.tag, node.props, (0, _children.getOwner)(node));\n\t\treturn true;\n\t}\n}\n\n/**\n * Handles an intercepted call to the attributes default handler from\n * incremental dom.\n * @param {!Element} element\n * @param {string} name\n * @param {*} value\n * @private\n */\nfunction handleInterceptedAttributesCall_(element, name, value) {\n\t(0, _attributes.applyAttribute)(getComponentBeingRendered(), element, name, value);\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom.\n * @param {string} tag\n * @private\n */\nfunction handleInterceptedOpenCall_(tag) {\n\tif (isComponentTag_(tag)) {\n\t\treturn handleSubComponentCall_.apply(null, arguments);\n\t} else {\n\t\treturn handleRegularCall_.apply(null, arguments);\n\t}\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom, done for a regular element. Among other things, adds any inline\n * listeners found on the first render and makes sure that component root\n * elements are always reused.\n * @param {!Component} owner\n * @param {!Array} args\n * @return {!Element} The rendered element.\n * @private\n */\nfunction handleRegularCall_() {\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\tvar config = (0, _callArgs.buildConfigFromCall)(args);\n\tvar tag = args[0];\n\n\tvar comp = getComponentBeingRendered();\n\tvar owner = comp;\n\tif ((0, _children.isChildTag)(tag)) {\n\t\towner = tag.owner;\n\t\ttag = tag.tag;\n\t}\n\tconfig.key = generateKey_(comp, config.key);\n\n\tif (!(0, _data.getData)(comp).rootElementReached) {\n\t\tvar elementClasses = comp.getDataManager().get(comp, 'elementClasses');\n\t\tif (elementClasses) {\n\t\t\taddElementClasses_(elementClasses, config);\n\t\t}\n\t}\n\t(0, _attributes.convertListenerNamesToFns)(comp, config);\n\n\tvar call = (0, _callArgs.buildCallFromConfig)(tag, config);\n\tvar node = (0, _incrementalDomAop.getOriginalFn)('elementOpen').apply(null, call);\n\tresetNodeData_(node);\n\tupdateElementIfNotReached_(comp, node);\n\n\tif ((0, _metal.isDefAndNotNull)(config.ref)) {\n\t\towner.refs[config.ref] = node;\n\t}\n\towner.getRenderer().handleNodeRendered(node);\n\n\treturn node;\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom, done for a sub component element. Creates and updates the appropriate\n * sub component.\n * @private\n */\nfunction handleSubComponentCall_() {\n\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\targs[_key2] = arguments[_key2];\n\t}\n\n\t(0, _children.captureChildren)(getComponentBeingRendered(), handleChildrenCaptured_, {\n\t\tprops: (0, _callArgs.buildConfigFromCall)(args),\n\t\ttag: args[0]\n\t});\n}\n\n/**\n * Passes down elementClasses to a child component if the parent component\n * returns another component at the top level (HOC).\n * @param {*} parent The parent component\n * @param {*} config The config of the subcomponent\n */\nfunction inheritElementClasses_(parent, config) {\n\tvar parentData = (0, _data.getData)(parent);\n\tvar parentConfig = parentData.config;\n\n\tif (!parentData.rootElementReached && parentConfig && (0, _metal.isString)(parentConfig.elementClasses)) {\n\t\tvar currentClasses = '';\n\t\tif ((0, _metal.isString)(config.elementClasses)) {\n\t\t\tcurrentClasses = config.elementClasses + ' ';\n\t\t}\n\n\t\tconfig.elementClasses = currentClasses + parentConfig.elementClasses;\n\t}\n}\n\n/**\n * Checks if the given tag represents a metal component.\n * @param {string} tag\n * @return {boolean}\n * @private\n */\nfunction isComponentTag_(tag) {\n\treturn (0, _metal.isFunction)(tag) || (0, _metal.isString)(tag) && tag[0] === tag[0].toUpperCase();\n}\n\n/**\n * Checks if the given component can be a match for a constructor.\n * @param {!Component} comp\n * @param {!function()} Ctor\n * @param {!Component} owner\n * @return {boolean}\n * @private\n */\nfunction isMatch_(comp, Ctor, owner) {\n\tif (!comp || comp.constructor !== Ctor || comp.isDisposed()) {\n\t\treturn false;\n\t}\n\treturn (0, _data.getData)(comp).owner === owner;\n}\n\n/**\n * Returns the given component if it matches the specified constructor\n * function. Otherwise, returns a new instance of the given constructor. On\n * both cases the component's state and config will be updated.\n * @param {Component} comp\n * @param {!function()} Ctor\n * @param {!Object} config\n * @param {!Component} owner\n * @return {!Component}\n * @private\n */\nfunction match_(comp, Ctor, config, owner) {\n\tif (isMatch_(comp, Ctor, owner)) {\n\t\tcomp.startSkipUpdates();\n\t\tcomp.getDataManager().replaceNonInternal(comp, config);\n\t\tcomp.stopSkipUpdates();\n\t} else {\n\t\tcomp = new Ctor(config, false);\n\t}\n\t(0, _data.getData)(comp).config = config;\n\treturn comp;\n}\n\n/**\n * Prepares the render operation, resetting the component's data and starting\n * the incremental dom interception.\n * @param {!Component} component\n * @private\n */\nfunction prepareRender_(component) {\n\trenderingComponents_.push(component);\n\n\tvar data = (0, _data.getData)(component);\n\tresetComponentsData_(data.icComponentsData);\n\t(0, _changes.clearChanges)(data);\n\tdata.rootElementReached = false;\n\tcomponent.refs = {};\n\n\tif (data.childComponents) {\n\t\t(0, _unused.schedule)(data.childComponents);\n\t\tdata.childComponents = null;\n\t}\n\n\t(0, _incrementalDomAop.startInterception)({\n\t\tattributes: handleInterceptedAttributesCall_,\n\t\telementOpen: handleInterceptedOpenCall_\n\t});\n}\n\n/**\n * Removes duplicate css classes from the given string.\n * @param {string} classString\n * @return {string}\n * @private\n */\nfunction removeDuplicateClasses_(classString) {\n\tvar classes = [];\n\tvar all = classString.split(/\\s+/);\n\tvar used = {};\n\tfor (var i = 0; i < all.length; i++) {\n\t\tif (!used[all[i]]) {\n\t\t\tused[all[i]] = true;\n\t\t\tclasses.push(all[i]);\n\t\t}\n\t}\n\treturn classes.join(' ');\n}\n\n/**\n * Renders the component with incremental dom function calls. This assumes that\n * an incremental dom `patch` is already running, and that this function has\n * been called inside it.\n * @param {!Component} component\n */\nfunction render(component) {\n\tprepareRender_(component);\n\tcomponent.getRenderer().renderIncDom(component);\n\tcleanUpRender_(component);\n}\n\n/**\n * Renders the given child node.\n * @param {!Object} child\n */\nfunction renderChild(child) {\n\t(0, _children.renderChildTree)(child, handleChildRender_);\n}\n\n/**\n * Renders the contents for the given tag.\n * @param {!function()|string} tag\n * @param {!Object} config\n * @param {Component=} opt_owner\n * @private\n */\nfunction renderFromTag_(tag, config, opt_owner) {\n\tif ((0, _metal.isString)(tag) || tag.prototype.getRenderer) {\n\t\tvar comp = renderSubComponent_(tag, config, opt_owner);\n\t\tupdateElementIfNotReached_(getComponentBeingRendered(), comp.element);\n\t\treturn comp.element;\n\t} else {\n\t\treturn tag(config);\n\t}\n}\n\n/**\n * Creates and renders the given function, which can either be a simple\n * incremental dom function or a component constructor.\n * @param {!IncrementalDomRenderer} renderer\n * @param {!function()} fnOrCtor Either a simple incremental dom function or a\n *     component constructor.\n * @param {Object|Element=} opt_dataOrElement Optional config data for the\n *     function or parent for the rendered content.\n * @param {Element=} opt_parent Optional parent for the rendered content.\n * @return {!Component} The rendered component's instance.\n */\nfunction renderFunction(renderer, fnOrCtor, opt_dataOrElement, opt_parent) {\n\tif (!_metalComponent.Component.isComponentCtor(fnOrCtor)) {\n\t\tvar fn = fnOrCtor;\n\n\t\tvar TempComponent = function (_Component) {\n\t\t\t_inherits(TempComponent, _Component);\n\n\t\t\tfunction TempComponent() {\n\t\t\t\t_classCallCheck(this, TempComponent);\n\n\t\t\t\treturn _possibleConstructorReturn(this, (TempComponent.__proto__ || Object.getPrototypeOf(TempComponent)).apply(this, arguments));\n\t\t\t}\n\n\t\t\t_createClass(TempComponent, [{\n\t\t\t\tkey: 'created',\n\t\t\t\tvalue: function created() {\n\t\t\t\t\tvar parent = getComponentBeingRendered();\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tupdateContext_(this, parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'render',\n\t\t\t\tvalue: function render() {\n\t\t\t\t\tfn(this.getInitialConfig());\n\t\t\t\t}\n\t\t\t}]);\n\n\t\t\treturn TempComponent;\n\t\t}(_metalComponent.Component);\n\n\t\tTempComponent.RENDERER = renderer;\n\t\tfnOrCtor = TempComponent;\n\t}\n\treturn _metalComponent.Component.render(fnOrCtor, opt_dataOrElement, opt_parent);\n}\n\n/**\n * This updates the sub component that is represented by the given data.\n * The sub component is created, added to its parent and rendered. If it\n * had already been rendered before though, it will only have its state\n * updated instead.\n * @param {string|!function()} tagOrCtor The tag name or constructor function.\n * @param {!Object} config The config object for the sub component.\n * @param {ComponentRenderer=} opt_owner\n * @return {!Component} The updated sub component.\n * @private\n */\nfunction renderSubComponent_(tagOrCtor, config, opt_owner) {\n\tvar parent = getComponentBeingRendered();\n\tvar owner = opt_owner || parent;\n\n\tinheritElementClasses_(parent, config);\n\n\tvar comp = getSubComponent_(tagOrCtor, config, owner);\n\tupdateContext_(comp, parent);\n\n\tvar data = (0, _data.getData)(comp);\n\tdata.parent = parent;\n\tdata.owner = owner;\n\n\tvar parentData = (0, _data.getData)(parent);\n\tgetChildComponents_(parentData).push(comp);\n\tif (!config.key && !parentData.rootElementReached) {\n\t\tconfig.key = parentData.config.key;\n\t}\n\n\tcomp.getRenderer().renderInsidePatch(comp);\n\tif (!comp.wasRendered) {\n\t\tcomp.renderComponent();\n\t}\n\treturn comp;\n}\n\n/**\n * Resets the given incremental dom data object, preparing it for the next pass.\n * @param {Object} data\n * @private\n */\nfunction resetComponentsData_(data) {\n\tif (data) {\n\t\tdata.prevComps = data.currComps;\n\t\tdata.currComps = null;\n\t\tdata.currCount = null;\n\t}\n}\n/**\n * Resets all data stored in the given node.\n * @param {!Element} node\n * @private\n */\nfunction resetNodeData_(node) {\n\tif (_metalDom.domData.has(node)) {\n\t\tresetComponentsData_(_metalDom.domData.get(node).icComponentsData);\n\t}\n}\n\n/**\n * Updates the given component's context according to the data from the\n * component that is currently being rendered.\n * @param {!Component} comp\n * @protected\n */\nfunction updateContext_(comp, parent) {\n\tvar context = comp.context;\n\tvar childContext = parent.getChildContext ? parent.getChildContext() : null;\n\t_metal.object.mixin(context, parent.context, childContext);\n\tcomp.context = context;\n}\n\n/**\n * Updates this renderer's component's element with the given values, unless\n * it has already been reached by an earlier call.\n * @param {!Component} component\n * @param {!Element} node\n * @private\n */\nfunction updateElementIfNotReached_(component, node) {\n\tvar data = (0, _data.getData)(component);\n\tif (!data.rootElementReached) {\n\t\tdata.rootElementReached = true;\n\t\tif (component.element !== node) {\n\t\t\tcomponent.element = node;\n\t\t}\n\t}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/render/render.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.addListenersFromObj = addListenersFromObj;\nexports.getComponentFn = getComponentFn;\n\nvar _metal = require('metal');\n\n/**\n * Adds the listeners specified in the given object.\n * @param {!Component} component\n * @param {Object} events\n * @return {!Array<!EventHandle>} Handles from all subscribed events.\n */\nfunction addListenersFromObj(component, events) {\n\tvar eventNames = Object.keys(events || {});\n\tvar handles = [];\n\tfor (var i = 0; i < eventNames.length; i++) {\n\t\tvar info = extractListenerInfo_(component, events[eventNames[i]]);\n\t\tif (info.fn) {\n\t\t\tvar handle = void 0;\n\t\t\tif (info.selector) {\n\t\t\t\thandle = component.delegate(eventNames[i], info.selector, info.fn);\n\t\t\t} else {\n\t\t\t\thandle = component.on(eventNames[i], info.fn);\n\t\t\t}\n\t\t\thandles.push(handle);\n\t\t}\n\t}\n\treturn handles;\n}\n\n/**\n * Extracts listener info from the given value.\n * @param {!Component} component\n * @param {!Component} component\n * @param {function()|string|{selector:string,fn:function()|string}} value\n * @return {!{selector:string,fn:function()}}\n * @protected\n */\nfunction extractListenerInfo_(component, value) {\n\tvar info = {\n\t\tfn: value\n\t};\n\tif ((0, _metal.isObject)(value) && !(0, _metal.isFunction)(value)) {\n\t\tinfo.selector = value.selector;\n\t\tinfo.fn = value.fn;\n\t}\n\tif ((0, _metal.isString)(info.fn)) {\n\t\tinfo.fn = getComponentFn(component, info.fn);\n\t}\n\treturn info;\n}\n\n/**\n * Gets the listener function from its name. Throws an error if none exist.\n * @param {!Component} component\n * @param {string} fnName\n * @return {function()}\n */\nfunction getComponentFn(component, fnName) {\n\tif ((0, _metal.isFunction)(component[fnName])) {\n\t\treturn component[fnName].bind(component);\n\t} else {\n\t\tconsole.error('No function named ' + fnName + ' was found in the component\\n\\t\\t\\t\"' + (0, _metal.getFunctionName)(component.constructor) + '\". Make sure that you specify\\n\\t\\t\\tvalid function names when adding inline listeners');\n\t}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-component/lib/events/events.js\n// module id = 23\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nvar _metalState = require('metal-state');\n\nvar _metalState2 = _interopRequireDefault(_metalState);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BLACKLIST = {\n\tcomponents: true,\n\tcontext: true,\n\telement: true,\n\trefs: true,\n\tstate: true,\n\tstateKey: true,\n\twasRendered: true\n};\nvar DATA_MANAGER_DATA = '__DATA_MANAGER_DATA__';\n\nvar ComponentDataManager = function () {\n\tfunction ComponentDataManager() {\n\t\t_classCallCheck(this, ComponentDataManager);\n\t}\n\n\t_createClass(ComponentDataManager, [{\n\t\tkey: 'createState_',\n\n\t\t/**\n   * Creates the `State` instance that will handle the main component data.\n   * @param {!Component} component\n   * @param {!Object} data\n   * @protected\n   */\n\t\tvalue: function createState_(component, data) {\n\t\t\tvar state = new _metalState2.default(component.getInitialConfig(), component, component);\n\t\t\tstate.setKeysBlacklist(BLACKLIST);\n\t\t\tstate.configState(_metal.object.mixin({}, data, _metalState2.default.getStateStatic(component.constructor)));\n\t\t\tthis.getManagerData(component).state_ = state;\n\t\t}\n\n\t\t/**\n   * Disposes of any data being used by the manager in this component.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'dispose',\n\t\tvalue: function dispose(component) {\n\t\t\tvar data = this.getManagerData(component);\n\t\t\tif (data.state_) {\n\t\t\t\tdata.state_.dispose();\n\t\t\t}\n\t\t\tcomponent[DATA_MANAGER_DATA] = null;\n\t\t}\n\n\t\t/**\n   * Gets the data with the given name.\n   * @param {!Component} component\n   * @param {string} name\n   * @return {*}\n   */\n\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(component, name) {\n\t\t\treturn this.getManagerData(component).state_.get(name);\n\t\t}\n\n\t\t/**\n   * Gets the manager data for the given component.\n   * @param {!Component} component\n   * @return {Object}\n   */\n\n\t}, {\n\t\tkey: 'getManagerData',\n\t\tvalue: function getManagerData(component) {\n\t\t\treturn component[DATA_MANAGER_DATA];\n\t\t}\n\n\t\t/**\n   * Gets the keys for state data that can be synced via `sync` functions.\n   * @param {!Component} component\n   * @return {!Array<string>}\n   */\n\n\t}, {\n\t\tkey: 'getSyncKeys',\n\t\tvalue: function getSyncKeys(component) {\n\t\t\treturn this.getManagerData(component).state_.getStateKeys();\n\t\t}\n\n\t\t/**\n   * Gets the keys for state data.\n   * @param {!Component} component\n   * @return {!Array<string>}\n   */\n\n\t}, {\n\t\tkey: 'getStateKeys',\n\t\tvalue: function getStateKeys(component) {\n\t\t\treturn this.getManagerData(component).state_.getStateKeys();\n\t\t}\n\n\t\t/**\n   * Gets the whole state data.\n   * @param {!Component} component\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getState',\n\t\tvalue: function getState(component) {\n\t\t\treturn this.getManagerData(component).state_.getState();\n\t\t}\n\n\t\t/**\n   * Gets the `State` instance being used.\n   * @param {!Component} component\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getStateInstance',\n\t\tvalue: function getStateInstance(component) {\n\t\t\treturn this.getManagerData(component).state_;\n\t\t}\n\n\t\t/**\n   * Updates all non internal data with the given values (or to the default\n   * value if none is given).\n   * @param {!Component} component\n   * @param {!Object} data\n   * @param {State=} opt_state\n   */\n\n\t}, {\n\t\tkey: 'replaceNonInternal',\n\t\tvalue: function replaceNonInternal(component, data, opt_state) {\n\t\t\tvar state = opt_state || this.getManagerData(component).state_;\n\t\t\tvar keys = state.getStateKeys();\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tif (!state.getStateKeyConfig(key).internal) {\n\t\t\t\t\tif (data.hasOwnProperty(key)) {\n\t\t\t\t\t\tstate.set(key, data[key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.setDefaultValue(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets the value of all the specified state keys.\n   * @param {!Component} component\n   * @param {!Object.<string,*>} values A map of state keys to the values they\n   *   should be set to.\n   * @param {function()=} opt_callback An optional function that will be run\n   *   after the next batched update is triggered.\n   */\n\n\t}, {\n\t\tkey: 'setState',\n\t\tvalue: function setState(component, state, opt_callback) {\n\t\t\tthis.getManagerData(component).state_.setState(state, opt_callback);\n\t\t}\n\n\t\t/**\n   * Sets up the specified component's data.\n   * @param {!Component} component\n   * @param {!Object} data\n   */\n\n\t}, {\n\t\tkey: 'setUp',\n\t\tvalue: function setUp(component, data) {\n\t\t\tcomponent[DATA_MANAGER_DATA] = {};\n\t\t\tthis.createState_(component, data);\n\t\t}\n\t}]);\n\n\treturn ComponentDataManager;\n}();\n\nexports.default = new ComponentDataManager();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-component/lib/ComponentDataManager.js\n// module id = 24\n// module chunks = 0","'use strict';\n\n/**\n * Base class that component renderers should extend from. It defines the\n * required methods all renderers should have.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ComponentRenderer = function () {\n\tfunction ComponentRenderer() {\n\t\t_classCallCheck(this, ComponentRenderer);\n\t}\n\n\t_createClass(ComponentRenderer, [{\n\t\tkey: 'dispose',\n\n\n\t\t/**\n   * Disposes of any data specific to the given component.\n   * @param {!Component} component\n   */\n\t\tvalue: function dispose() {}\n\n\t\t/**\n   * Returns extra configuration for data that should be added to the manager.\n   * Sub classes can override to return `State` config for properties that\n   * should be added to the component.\n   * @param {!Component} component\n   * @return {Object}\n   */\n\n\t}, {\n\t\tkey: 'getExtraDataConfig',\n\t\tvalue: function getExtraDataConfig() {}\n\n\t\t/**\n   * Renders the whole content (including its main element) and informs the\n   * component about it. Should be overridden by sub classes.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(component) {\n\t\t\tif (!component.element) {\n\t\t\t\tcomponent.element = document.createElement('div');\n\t\t\t}\n\t\t\tcomponent.informRendered();\n\t\t}\n\n\t\t/**\n   * Sets up this component to be used by this renderer. Sub classes should\n   * override as needed for more behavior.\n   * @param {!Component} component\n   */\n\n\t}, {\n\t\tkey: 'setUp',\n\t\tvalue: function setUp() {}\n\n\t\t/**\n   * Updates the component's element html. This is automatically called when\n   * the value of at least one of the component's state keys has changed.\n   * Should be implemented by sub classes. Sub classes have to remember to call\n   * \"informRendered\" on the component when any update rendering is done.\n   * @param {!Component} component\n   * @param {Object.<string, Object>} changes Object containing the names\n   *     of all changed state keys, each mapped to an object with its new\n   *     (newVal) and previous (prevVal) values.\n   */\n\n\t}, {\n\t\tkey: 'update',\n\t\tvalue: function update() {}\n\t}]);\n\n\treturn ComponentRenderer;\n}();\n\nexports.default = new ComponentRenderer();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-component/lib/ComponentRenderer.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _metal = require('metal');\n\nvar _metalIncrementalDom = require('metal-incremental-dom');\n\nvar _metalIncrementalDom2 = _interopRequireDefault(_metalIncrementalDom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar COUNT_PROP = '__metalJsxCount';\nvar INC_DOM_DATA = '__incrementalDOMData';\nvar KEY_PREFIX = '_metal_jsx_';\n\n/**\n * Renderer that handles JSX.\n */\n\nvar JSXRenderer = function (_IncrementalDomRender) {\n\t_inherits(JSXRenderer, _IncrementalDomRender);\n\n\tfunction JSXRenderer() {\n\t\t_classCallCheck(this, JSXRenderer);\n\n\t\treturn _possibleConstructorReturn(this, (JSXRenderer.__proto__ || Object.getPrototypeOf(JSXRenderer)).apply(this, arguments));\n\t}\n\n\t_createClass(JSXRenderer, [{\n\t\tkey: 'buildShouldUpdateArgs',\n\n\t\t/**\n   * @inheritDoc\n   */\n\t\tvalue: function buildShouldUpdateArgs(changes) {\n\t\t\treturn [changes.state, changes.props];\n\t\t}\n\n\t\t/**\n   * Called when generating a key for the next dom element to be created via\n   * incremental dom. Adds keys to elements that don't have one yet, according\n   * to their position in the parent. This helps use cases that use\n   * conditionally rendered elements, which is very common in JSX.\n   * @param {!Component} component\n   * @param {string} key\n   * @return {?string}\n   */\n\n\t}, {\n\t\tkey: 'generateKey',\n\t\tvalue: function generateKey(component, key) {\n\t\t\tkey = _get(JSXRenderer.prototype.__proto__ || Object.getPrototypeOf(JSXRenderer.prototype), 'generateKey', this).call(this, component, key);\n\t\t\tvar comp = this.getPatchingComponent();\n\t\t\tvar data = comp.getRenderer().getData(comp);\n\t\t\tif (!(0, _metal.isDefAndNotNull)(key)) {\n\t\t\t\tif (data.rootElementRendered) {\n\t\t\t\t\tkey = KEY_PREFIX + jsxRenderer_.incElementCount();\n\t\t\t\t} else if (comp.element && comp.element[INC_DOM_DATA]) {\n\t\t\t\t\tkey = comp.element[INC_DOM_DATA].key;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!data.rootElementRendered) {\n\t\t\t\tdata.rootElementRendered = true;\n\t\t\t}\n\t\t\treturn key;\n\t\t}\n\n\t\t/**\n   * @inheritDoc\n   */\n\n\t}, {\n\t\tkey: 'handleNodeRendered',\n\t\tvalue: function handleNodeRendered(node) {\n\t\t\tnode[COUNT_PROP] = 0;\n\t\t}\n\n\t\t/**\n   * Increments the number of children in the current element.\n   */\n\n\t}, {\n\t\tkey: 'incElementCount',\n\t\tvalue: function incElementCount() {\n\t\t\tvar node = IncrementalDOM.currentElement();\n\t\t\tnode[COUNT_PROP] = (node[COUNT_PROP] || 0) + 1;\n\t\t\treturn node[COUNT_PROP];\n\t\t}\n\n\t\t/**\n   * Overrides the original method from `IncrementalDomRenderer` so we can\n   * keep track of if the root element of the patched component has already\n   * been rendered or not.\n   * @param {!Component} component\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'patch',\n\t\tvalue: function patch(component) {\n\t\t\tthis.getData(component).rootElementRendered = false;\n\t\t\t_get(JSXRenderer.prototype.__proto__ || Object.getPrototypeOf(JSXRenderer.prototype), 'patch', this).call(this, component);\n\t\t}\n\n\t\t/**\n   * Overrides the original method from `IncrementalDomRenderer` to handle the\n   * case where developers return a child node directly from the \"render\"\n   * function.\n   * @param {!Component} component\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'renderIncDom',\n\t\tvalue: function renderIncDom(component) {\n\t\t\tif (component.render) {\n\t\t\t\tiDOMHelpers.renderArbitrary(component.render());\n\t\t\t} else {\n\t\t\t\t_get(JSXRenderer.prototype.__proto__ || Object.getPrototypeOf(JSXRenderer.prototype), 'renderIncDom', this).call(this, component);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Skips the current child in the count (used when a conditional render\n   * decided not to render anything).\n   */\n\n\t}, {\n\t\tkey: 'skipChild',\n\t\tvalue: function skipChild() {\n\t\t\tIncrementalDOM.elementVoid(jsxRenderer_.incElementCount);\n\t\t}\n\n\t\t/**\n   * @inheritDoc\n   */\n\n\t}, {\n\t\tkey: 'skipRender',\n\t\tvalue: function skipRender() {\n\t\t\tjsxRenderer_.skipChild();\n\t\t\t_get(JSXRenderer.prototype.__proto__ || Object.getPrototypeOf(JSXRenderer.prototype), 'skipRender', this).call(this);\n\t\t}\n\t}]);\n\n\treturn JSXRenderer;\n}(_metalIncrementalDom2.default.constructor);\n\nvar jsxRenderer_ = new JSXRenderer();\njsxRenderer_.RENDERER_NAME = 'jsx';\n\nexports.default = jsxRenderer_;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-jsx/lib/JSXRenderer.js\n// module id = 26\n// module chunks = 0","export { AGP } from \"./agp\";\r\n \n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import JSXComponent from 'metal-jsx';\r\n\r\nclass AGP extends JSXComponent {\r\n    created() {\r\n        console.log(\"Element created.\");\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>AGP</div>\r\n        );\r\n    }\r\n}\r\n\r\nexport { AGP };\r\nexport default AGP;\n\n\n// WEBPACK FOOTER //\n// ./src/agp.tsx","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSXComponent = exports.Config = exports.validators = exports.DangerouslySetHTML = undefined;\n\nvar _metalState = require('metal-state');\n\nvar _DangerouslySetHTML = require('../DangerouslySetHTML');\n\nvar _DangerouslySetHTML2 = _interopRequireDefault(_DangerouslySetHTML);\n\nvar _JSXComponent = require('../JSXComponent');\n\nvar _JSXComponent2 = _interopRequireDefault(_JSXComponent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _JSXComponent2.default;\nexports.DangerouslySetHTML = _DangerouslySetHTML2.default;\nexports.validators = _metalState.validators;\nexports.Config = _metalState.Config;\nexports.JSXComponent = _JSXComponent2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-jsx/lib/all/jsx.js\n// module id = 29\n// module chunks = 0","'use strict';\n\n/**\n * A collection of core utility functions.\n * @const\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.abstractMethod = abstractMethod;\nexports.disableCompatibilityMode = disableCompatibilityMode;\nexports.enableCompatibilityMode = enableCompatibilityMode;\nexports.getCompatibilityModeData = getCompatibilityModeData;\nexports.getFunctionName = getFunctionName;\nexports.getStaticProperty = getStaticProperty;\nexports.getUid = getUid;\nexports.identityFunction = identityFunction;\nexports.isBoolean = isBoolean;\nexports.isDef = isDef;\nexports.isDefAndNotNull = isDefAndNotNull;\nexports.isDocument = isDocument;\nexports.isDocumentFragment = isDocumentFragment;\nexports.isElement = isElement;\nexports.isFunction = isFunction;\nexports.isNull = isNull;\nexports.isNumber = isNumber;\nexports.isWindow = isWindow;\nexports.isObject = isObject;\nexports.isPromise = isPromise;\nexports.isString = isString;\nexports.isServerSide = isServerSide;\nexports.nullFunction = nullFunction;\nvar compatibilityModeData_ = void 0;\n\n/**\n * Counter for unique id.\n * @type {Number}\n * @private\n */\nvar uniqueIdCounter_ = 1;\n\n/**\n * Unique id property prefix.\n * @type {String}\n * @protected\n */\nvar UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);\n\n/**\n * When defining a class Foo with an abstract method bar(), you can do:\n * Foo.prototype.bar = abstractMethod\n *\n * Now if a subclass of Foo fails to override bar(), an error will be thrown\n * when bar() is invoked.\n *\n * @type {!Function}\n * @throws {Error} when invoked to indicate the method should be overridden.\n */\nfunction abstractMethod() {\n  throw Error('Unimplemented abstract method');\n}\n\n/**\n * Disables Metal.js's compatibility mode.\n */\nfunction disableCompatibilityMode() {\n  compatibilityModeData_ = undefined;\n}\n\n/**\n * Enables Metal.js's compatibility mode with the following features from rc\n * and 1.x versions:\n *     - Using \"key\" to reference component instances. In the current version\n *       this should be done via \"ref\" instead. This allows old code still\n *       using \"key\" to keep working like before. NOTE: this may cause\n *       problems, since \"key\" is meant to be used differently. Only use this\n *       if it's not possible to upgrade the code to use \"ref\" instead.\n * @param {Object=} opt_data Optional object with data to specify more\n *     details, such as:\n *         - renderers {Array} the template renderers that should be in\n *           compatibility mode, either their constructors or strings\n *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones\n *           that extend from IncrementalDomRenderer.\n * @type {Object}\n */\nfunction enableCompatibilityMode() {\n  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  compatibilityModeData_ = opt_data;\n}\n\n/**\n * Returns the data used for compatibility mode, or nothing if it hasn't been\n * enabled.\n * @return {Object}\n */\nfunction getCompatibilityModeData() {\n  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.\n  if (compatibilityModeData_ === undefined) {\n    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {\n      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);\n    }\n  }\n  return compatibilityModeData_;\n}\n\n/**\n * Returns the first argument if it's truthy, or the second otherwise.\n * @param {*} a\n * @param {*} b\n * @return {*}\n * @protected\n */\nfunction getFirstTruthy_(a, b) {\n  return a || b;\n}\n\n/**\n * Gets the name of the given function. If the current browser doesn't\n * support the `name` property, this will calculate it from the function's\n * content string.\n * @param {!function()} fn\n * @return {string}\n */\nfunction getFunctionName(fn) {\n  if (!fn.name) {\n    var str = fn.toString();\n    fn.name = str.substring(9, str.indexOf('('));\n  }\n  return fn.name;\n}\n\n/**\n * Gets the value of a static property in the given class. The value will be\n * inherited from ancestors as expected, unless a custom merge function is given,\n * which can change how the super classes' value for that property will be merged\n * together.\n * The final merged value will be stored in another property, so that it won't\n * be recalculated even if this function is called multiple times.\n * @param {!function()} ctor Class constructor.\n * @param {string} propertyName Property name to be merged.\n * @param {function(*, *):*=} opt_mergeFn Function that receives the merged\n *     value of the property so far and the next value to be merged to it.\n *     Should return these two merged together. If not passed the final property\n *     will be the first truthy value among ancestors.\n */\nfunction getStaticProperty(ctor, propertyName, opt_mergeFn) {\n  var mergedName = propertyName + '_MERGED';\n  if (!ctor.hasOwnProperty(mergedName)) {\n    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;\n    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {\n      var mergeFn = opt_mergeFn || getFirstTruthy_;\n      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));\n    }\n    ctor[mergedName] = merged;\n  }\n  return ctor[mergedName];\n}\n\n/**\n * Gets an unique id. If `opt_object` argument is passed, the object is\n * mutated with an unique id. Consecutive calls with the same object\n * reference won't mutate the object again, instead the current object uid\n * returns. See {@link UID_PROPERTY}.\n * @param {Object=} opt_object Optional object to be mutated with the uid. If\n *     not specified this method only returns the uid.\n * @param {boolean=} opt_noInheritance Optional flag indicating if this\n *     object's uid property can be inherited from parents or not.\n * @throws {Error} when invoked to indicate the method should be overridden.\n */\nfunction getUid(opt_object, opt_noInheritance) {\n  if (opt_object) {\n    var id = opt_object[UID_PROPERTY];\n    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {\n      id = null;\n    }\n    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);\n  }\n  return uniqueIdCounter_++;\n}\n\n/**\n * The identity function. Returns its first argument.\n * @param {*=} opt_returnValue The single value that will be returned.\n * @return {?} The first argument.\n */\nfunction identityFunction(opt_returnValue) {\n  return opt_returnValue;\n}\n\n/**\n * Returns true if the specified value is a boolean.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is boolean.\n */\nfunction isBoolean(val) {\n  return typeof val === 'boolean';\n}\n\n/**\n * Returns true if the specified value is not undefined.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is defined.\n */\nfunction isDef(val) {\n  return val !== undefined;\n}\n\n/**\n * Returns true if value is not undefined or null.\n * @param {*} val\n * @return {boolean}\n */\nfunction isDefAndNotNull(val) {\n  return isDef(val) && !isNull(val);\n}\n\n/**\n * Returns true if value is a document.\n * @param {*} val\n * @return {boolean}\n */\nfunction isDocument(val) {\n  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;\n}\n\n/**\n * Returns true if value is a document-fragment.\n * @param {*} val\n * @return {boolean}\n */\nfunction isDocumentFragment(val) {\n  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;\n}\n\n/**\n * Returns true if value is a dom element.\n * @param {*} val\n * @return {boolean}\n */\nfunction isElement(val) {\n  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;\n}\n\n/**\n * Returns true if the specified value is a function.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a function.\n */\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\n/**\n * Returns true if value is null.\n * @param {*} val\n * @return {boolean}\n */\nfunction isNull(val) {\n  return val === null;\n}\n\n/**\n * Returns true if the specified value is a number.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a number.\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Returns true if value is a window.\n * @param {*} val\n * @return {boolean}\n */\nfunction isWindow(val) {\n  return val !== null && val === val.window;\n}\n\n/**\n * Returns true if the specified value is an object. This includes arrays\n * and functions.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is an object.\n */\nfunction isObject(val) {\n  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);\n  return type === 'object' && val !== null || type === 'function';\n}\n\n/**\n * Returns true if value is a Promise.\n * @param {*} val\n * @return {boolean}\n */\nfunction isPromise(val) {\n  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';\n}\n\n/**\n * Returns true if value is a string.\n * @param {*} val\n * @return {boolean}\n */\nfunction isString(val) {\n  return typeof val === 'string' || val instanceof String;\n}\n\n/**\n * Sets to true if running inside Node.js environment with extra check for\n * `process.browser` to skip Karma runner environment. Karma environment has\n * `process` defined even though it runs on the browser.\n * @return {boolean}\n */\nfunction isServerSide() {\n  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && process.env.NODE_ENV !== 'test' && !process.browser;\n}\n\n/**\n * Null function used for default values of callbacks, etc.\n * @return {void} Nothing.\n */\nfunction nullFunction() {}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/coreNamed.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _core = require('../core');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar array = function () {\n\tfunction array() {\n\t\t_classCallCheck(this, array);\n\t}\n\n\t_createClass(array, null, [{\n\t\tkey: 'equal',\n\n\t\t/**\n   * Checks if the given arrays have the same content.\n   * @param {!Array<*>} arr1\n   * @param {!Array<*>} arr2\n   * @return {boolean}\n   */\n\t\tvalue: function equal(arr1, arr2) {\n\t\t\tif (arr1 === arr2) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (arr1.length !== arr2.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < arr1.length; i++) {\n\t\t\t\tif (arr1[i] !== arr2[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n   * Returns the first value in the given array that isn't undefined.\n   * @param {!Array} arr\n   * @return {*}\n   */\n\n\t}, {\n\t\tkey: 'firstDefinedValue',\n\t\tvalue: function firstDefinedValue(arr) {\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tif (arr[i] !== undefined) {\n\t\t\t\t\treturn arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Transforms the input nested array to become flat.\n   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.\n   * @param {Array.<*>} opt_output Optional output array.\n   * @return {Array.<*>} Flat array.\n   */\n\n\t}, {\n\t\tkey: 'flatten',\n\t\tvalue: function flatten(arr, opt_output) {\n\t\t\tvar output = opt_output || [];\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tif (Array.isArray(arr[i])) {\n\t\t\t\t\tarray.flatten(arr[i], output);\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n   * Removes the first occurrence of a particular value from an array.\n   * @param {Array.<T>} arr Array from which to remove value.\n   * @param {T} obj Object to remove.\n   * @return {boolean} True if an element was removed.\n   * @template T\n   */\n\n\t}, {\n\t\tkey: 'remove',\n\t\tvalue: function remove(arr, obj) {\n\t\t\tvar i = arr.indexOf(obj);\n\t\t\tvar rv = void 0;\n\t\t\tif (rv = i >= 0) {\n\t\t\t\tarray.removeAt(arr, i);\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t/**\n   * Removes from an array the element at index i\n   * @param {Array} arr Array or array like object from which to remove value.\n   * @param {number} i The index to remove.\n   * @return {boolean} True if an element was removed.\n   */\n\n\t}, {\n\t\tkey: 'removeAt',\n\t\tvalue: function removeAt(arr, i) {\n\t\t\treturn Array.prototype.splice.call(arr, i, 1).length === 1;\n\t\t}\n\n\t\t/**\n   * Slices the given array, just like Array.prototype.slice, but this\n   * is faster and working on all array-like objects (like arguments).\n   * @param {!Object} arr Array-like object to slice.\n   * @param {number} start The index that should start the slice.\n   * @param {number=} opt_end The index where the slice should end, not\n   *   included in the final array. If not given, all elements after the\n   *   start index will be included.\n   * @return {!Array}\n   */\n\n\t}, {\n\t\tkey: 'slice',\n\t\tvalue: function slice(arr, start, opt_end) {\n\t\t\tvar sliced = [];\n\t\t\tvar end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;\n\t\t\tfor (var i = start; i < end; i++) {\n\t\t\t\tsliced.push(arr[i]);\n\t\t\t}\n\t\t\treturn sliced;\n\t\t}\n\t}]);\n\n\treturn array;\n}();\n\nexports.default = array;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/array/array.js\n// module id = 31\n// module chunks = 0","/*!\n * Polyfill from Google's Closure Library.\n * Copyright 2013 The Closure Library Authors. All Rights Reserved.\n */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar async = {};\n\n/**\n * Throw an item without interrupting the current execution context.  For\n * example, if processing a group of items in a loop, sometimes it is useful\n * to report an error while still allowing the rest of the batch to be\n * processed.\n * @param {*} exception\n */\nasync.throwException = function (exception) {\n\t// Each throw needs to be in its own context.\n\tasync.nextTick(function () {\n\t\tthrow exception;\n\t});\n};\n\n/**\n * Fires the provided callback just before the current callstack unwinds, or as\n * soon as possible after the current JS execution context.\n * @param {function(this:THIS)} callback\n * @param {THIS=} opt_context Object to use as the \"this value\" when calling\n *     the provided function.\n * @template THIS\n */\nasync.run = function (callback, opt_context) {\n\tif (!async.run.workQueueScheduled_) {\n\t\t// Nothing is currently scheduled, schedule it now.\n\t\tasync.nextTick(async.run.processWorkQueue);\n\t\tasync.run.workQueueScheduled_ = true;\n\t}\n\n\tasync.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));\n};\n\n/** @private {boolean} */\nasync.run.workQueueScheduled_ = false;\n\n/** @private {!Array.<!async.run.WorkItem_>} */\nasync.run.workQueue_ = [];\n\n/**\n * Run any pending async.run work items. This function is not intended\n * for general use, but for use by entry point handlers to run items ahead of\n * async.nextTick.\n */\nasync.run.processWorkQueue = function () {\n\t// NOTE: additional work queue items may be pushed while processing.\n\twhile (async.run.workQueue_.length) {\n\t\t// Don't let the work queue grow indefinitely.\n\t\tvar workItems = async.run.workQueue_;\n\t\tasync.run.workQueue_ = [];\n\t\tfor (var i = 0; i < workItems.length; i++) {\n\t\t\tvar workItem = workItems[i];\n\t\t\ttry {\n\t\t\t\tworkItem.fn.call(workItem.scope);\n\t\t\t} catch (e) {\n\t\t\t\tasync.throwException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t// There are no more work items, reset the work queue.\n\tasync.run.workQueueScheduled_ = false;\n};\n\n/**\n * @constructor\n * @final\n * @struct\n * @private\n *\n * @param {function()} fn\n * @param {Object|null|undefined} scope\n */\nasync.run.WorkItem_ = function (fn, scope) {\n\t/** @const */\n\tthis.fn = fn;\n\t/** @const */\n\tthis.scope = scope;\n};\n\n/**\n * Fires the provided callbacks as soon as possible after the current JS\n * execution context. setTimeout(, 0) always takes at least 5ms for legacy\n * reasons.\n * @param {function(this:SCOPE)} callback Callback function to fire as soon as\n *     possible.\n * @param {SCOPE=} opt_context Object in whose scope to call the listener.\n * @template SCOPE\n */\nasync.nextTick = function (callback, opt_context) {\n\tvar cb = callback;\n\tif (opt_context) {\n\t\tcb = callback.bind(opt_context);\n\t}\n\tcb = async.nextTick.wrapCallback_(cb);\n\t// Introduced and currently only supported by IE10.\n\t// Verify if variable is defined on the current runtime (i.e., node, browser).\n\t// Can't use typeof enclosed in a function (such as core.isFunction) or an\n\t// exception will be thrown when the function is called on an environment\n\t// where the variable is undefined.\n\tif (typeof setImmediate === 'function') {\n\t\tsetImmediate(cb);\n\t\treturn;\n\t}\n\t// Look for and cache the custom fallback version of setImmediate.\n\tif (!async.nextTick.setImmediate_) {\n\t\tasync.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();\n\t}\n\tasync.nextTick.setImmediate_(cb);\n};\n\n/**\n * Cache for the setImmediate implementation.\n * @type {function(function())}\n * @private\n */\nasync.nextTick.setImmediate_ = null;\n\n/**\n * Determines the best possible implementation to run a function as soon as\n * the JS event loop is idle.\n * @return {function(function())} The \"setImmediate\" implementation.\n * @private\n */\nasync.nextTick.getSetImmediateEmulator_ = function () {\n\t// Create a private message channel and use it to postMessage empty messages\n\t// to ourselves.\n\tvar Channel = void 0;\n\n\t// Verify if variable is defined on the current runtime (i.e., node, browser).\n\t// Can't use typeof enclosed in a function (such as core.isFunction) or an\n\t// exception will be thrown when the function is called on an environment\n\t// where the variable is undefined.\n\tif (typeof MessageChannel === 'function') {\n\t\tChannel = MessageChannel;\n\t}\n\n\t// If MessageChannel is not available and we are in a browser, implement\n\t// an iframe based polyfill in browsers that have postMessage and\n\t// document.addEventListener. The latter excludes IE8 because it has a\n\t// synchronous postMessage implementation.\n\tif (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {\n\t\t/** @constructor */\n\t\tChannel = function Channel() {\n\t\t\t// Make an empty, invisible iframe.\n\t\t\tvar iframe = document.createElement('iframe');\n\t\t\tiframe.style.display = 'none';\n\t\t\tiframe.src = '';\n\t\t\tdocument.documentElement.appendChild(iframe);\n\t\t\tvar win = iframe.contentWindow;\n\t\t\tvar doc = win.document;\n\t\t\tdoc.open();\n\t\t\tdoc.write('');\n\t\t\tdoc.close();\n\t\t\tvar message = 'callImmediate' + Math.random();\n\t\t\tvar origin = win.location.protocol + '//' + win.location.host;\n\t\t\tvar onmessage = function (e) {\n\t\t\t\t// Validate origin and message to make sure that this message was\n\t\t\t\t// intended for us.\n\t\t\t\tif (e.origin !== origin && e.data !== message) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.port1.onmessage();\n\t\t\t}.bind(this);\n\t\t\twin.addEventListener('message', onmessage, false);\n\t\t\tthis.port1 = {};\n\t\t\tthis.port2 = {\n\t\t\t\tpostMessage: function postMessage() {\n\t\t\t\t\twin.postMessage(message, origin);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\tif (typeof Channel !== 'undefined') {\n\t\tvar channel = new Channel();\n\t\t// Use a fifo linked list to call callbacks in the right order.\n\t\tvar head = {};\n\t\tvar tail = head;\n\t\tchannel.port1.onmessage = function () {\n\t\t\thead = head.next;\n\t\t\tvar cb = head.cb;\n\t\t\thead.cb = null;\n\t\t\tcb();\n\t\t};\n\t\treturn function (cb) {\n\t\t\ttail.next = {\n\t\t\t\tcb: cb\n\t\t\t};\n\t\t\ttail = tail.next;\n\t\t\tchannel.port2.postMessage(0);\n\t\t};\n\t}\n\t// Implementation for IE6-8: Script elements fire an asynchronous\n\t// onreadystatechange event when inserted into the DOM.\n\tif (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {\n\t\treturn function (cb) {\n\t\t\tvar script = document.createElement('script');\n\t\t\tscript.onreadystatechange = function () {\n\t\t\t\t// Clean up and call the callback.\n\t\t\t\tscript.onreadystatechange = null;\n\t\t\t\tscript.parentNode.removeChild(script);\n\t\t\t\tscript = null;\n\t\t\t\tcb();\n\t\t\t\tcb = null;\n\t\t\t};\n\t\t\tdocument.documentElement.appendChild(script);\n\t\t};\n\t}\n\t// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms\n\t// or more.\n\treturn function (cb) {\n\t\tsetTimeout(cb, 0);\n\t};\n};\n\n/**\n * Helper function that is overrided to protect callbacks with entry point\n * monitor if the application monitors entry points.\n * @param {function()} callback Callback function to fire as soon as possible.\n * @return {function()} The wrapped callback.\n * @private\n */\nasync.nextTick.wrapCallback_ = function (opt_returnValue) {\n\treturn opt_returnValue;\n};\n\nexports.default = async;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/async/async.js\n// module id = 32\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/timers-browserify/main.js\n// module id = 33\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/setimmediate/setImmediate.js\n// module id = 34\n// module chunks = 0","'use strict';\n\n/**\n * Disposable utility. When inherited provides the `dispose` function to its\n * subclass, which is responsible for disposing of any object references\n * when an instance won't be used anymore. Subclasses should override\n * `disposeInternal` to implement any specific disposing logic.\n * @constructor\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Disposable = function () {\n\tfunction Disposable() {\n\t\t_classCallCheck(this, Disposable);\n\n\t\t/**\n   * Flag indicating if this instance has already been disposed.\n   * @type {boolean}\n   * @protected\n   */\n\t\tthis.disposed_ = false;\n\t}\n\n\t/**\n  * Disposes of this instance's object references. Calls `disposeInternal`.\n  */\n\n\n\t_createClass(Disposable, [{\n\t\tkey: 'dispose',\n\t\tvalue: function dispose() {\n\t\t\tif (!this.disposed_) {\n\t\t\t\tthis.disposeInternal();\n\t\t\t\tthis.disposed_ = true;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Subclasses should override this method to implement any specific\n   * disposing logic (like clearing references and calling `dispose` on other\n   * disposables).\n   */\n\n\t}, {\n\t\tkey: 'disposeInternal',\n\t\tvalue: function disposeInternal() {}\n\n\t\t/**\n   * Checks if this instance has already been disposed.\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'isDisposed',\n\t\tvalue: function isDisposed() {\n\t\t\treturn this.disposed_;\n\t\t}\n\t}]);\n\n\treturn Disposable;\n}();\n\nexports.default = Disposable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/disposable/Disposable.js\n// module id = 35\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar object = function () {\n\tfunction object() {\n\t\t_classCallCheck(this, object);\n\t}\n\n\t_createClass(object, null, [{\n\t\tkey: 'mixin',\n\n\t\t/**\n   * Copies all the members of a source object to a target object.\n   * @param {Object} target Target object.\n   * @param {...Object} var_args The objects from which values will be copied.\n   * @return {Object} Returns the target object reference.\n   */\n\t\tvalue: function mixin(target) {\n\t\t\tvar key = void 0,\n\t\t\t    source = void 0;\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\tsource = arguments[i];\n\t\t\t\tfor (key in source) {\n\t\t\t\t\ttarget[key] = source[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target;\n\t\t}\n\n\t\t/**\n   * Returns an object based on its fully qualified external name.\n   * @param {string} name The fully qualified name.\n   * @param {object=} opt_obj The object within which to look; default is\n   *     <code>window</code>.\n   * @return {?} The value (object or primitive) or, if not found, undefined.\n   */\n\n\t}, {\n\t\tkey: 'getObjectByName',\n\t\tvalue: function getObjectByName(name, opt_obj) {\n\t\t\tvar scope = opt_obj || window;\n\t\t\tvar parts = name.split('.');\n\t\t\treturn parts.reduce(function (part, key) {\n\t\t\t\treturn part[key];\n\t\t\t}, scope);\n\t\t}\n\n\t\t/**\n   * Returns a new object with the same keys as the given one, but with\n   * their values set to the return values of the specified function.\n   * @param {!Object} obj\n   * @param {!function(string, *)} fn\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'map',\n\t\tvalue: function map(obj, fn) {\n\t\t\tvar mappedObj = {};\n\t\t\tvar keys = Object.keys(obj);\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tmappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);\n\t\t\t}\n\t\t\treturn mappedObj;\n\t\t}\n\n\t\t/**\n   * Checks if the two given objects are equal. This is done via a shallow\n   * check, including only the keys directly contained by the 2 objects.\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'shallowEqual',\n\t\tvalue: function shallowEqual(obj1, obj2) {\n\t\t\tif (obj1 === obj2) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar keys1 = Object.keys(obj1);\n\t\t\tvar keys2 = Object.keys(obj2);\n\t\t\tif (keys1.length !== keys2.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < keys1.length; i++) {\n\t\t\t\tif (obj1[keys1[i]] !== obj2[keys1[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}]);\n\n\treturn object;\n}();\n\nexports.default = object;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/object/object.js\n// module id = 36\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar string = function () {\n\tfunction string() {\n\t\t_classCallCheck(this, string);\n\t}\n\n\t_createClass(string, null, [{\n\t\tkey: 'caseInsensitiveCompare',\n\n\t\t/**\n   * Compares the given strings without taking the case into account.\n   * @param {string|number} str1\n   * @param {string|number} str2\n   * @return {number} Either -1, 0 or 1, according to if the first string is\n   *     \"smaller\", equal or \"bigger\" than the second given string.\n   */\n\t\tvalue: function caseInsensitiveCompare(str1, str2) {\n\t\t\tvar test1 = String(str1).toLowerCase();\n\t\t\tvar test2 = String(str2).toLowerCase();\n\n\t\t\tif (test1 < test2) {\n\t\t\t\treturn -1;\n\t\t\t} else if (test1 === test2) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Removes the breaking spaces from the left and right of the string and\n   * collapses the sequences of breaking spaces in the middle into single spaces.\n   * The original and the result strings render the same way in HTML.\n   * @param {string} str A string in which to collapse spaces.\n   * @return {string} Copy of the string with normalized breaking spaces.\n   */\n\n\t}, {\n\t\tkey: 'collapseBreakingSpaces',\n\t\tvalue: function collapseBreakingSpaces(str) {\n\t\t\treturn str.replace(/[\\t\\r\\n ]+/g, ' ').replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, '');\n\t\t}\n\n\t\t/**\n  * Escapes characters in the string that are not safe to use in a RegExp.\n  * @param {*} str The string to escape. If not a string, it will be casted\n  *     to one.\n  * @return {string} A RegExp safe, escaped copy of {@code s}.\n  */\n\n\t}, {\n\t\tkey: 'escapeRegex',\n\t\tvalue: function escapeRegex(str) {\n\t\t\treturn String(str).replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').replace(/\\x08/g, '\\\\x08');\n\t\t}\n\n\t\t/**\n  * Returns a string with at least 64-bits of randomness.\n  * @return {string} A random string, e.g. sn1s7vb4gcic.\n  */\n\n\t}, {\n\t\tkey: 'getRandomString',\n\t\tvalue: function getRandomString() {\n\t\t\tvar x = 2147483648;\n\t\t\treturn Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);\n\t\t}\n\n\t\t/**\n   * Calculates the hashcode for a string. The hashcode value is computed by\n   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice\n   * property of using 31 prime is that the multiplication can be replaced by\n   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.\n   * Modern VMs do this sort of optimization automatically.\n   * @param {String} val Target string.\n   * @return {Number} Returns the string hashcode.\n   */\n\n\t}, {\n\t\tkey: 'hashCode',\n\t\tvalue: function hashCode(val) {\n\t\t\tvar hash = 0;\n\t\t\tfor (var i = 0, len = val.length; i < len; i++) {\n\t\t\t\thash = 31 * hash + val.charCodeAt(i);\n\t\t\t\thash %= 0x100000000;\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\t/**\n   * Replaces interval into the string with specified value, e.g.\n   * `replaceInterval(\"abcde\", 1, 4, \"\")` returns \"ae\".\n   * @param {string} str The input string.\n   * @param {Number} start Start interval position to be replaced.\n   * @param {Number} end End interval position to be replaced.\n   * @param {string} value The value that replaces the specified interval.\n   * @return {string}\n   */\n\n\t}, {\n\t\tkey: 'replaceInterval',\n\t\tvalue: function replaceInterval(str, start, end, value) {\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\n\t\t}\n\t}]);\n\n\treturn string;\n}();\n\nexports.default = string;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal/lib/string/string.js\n// module id = 37\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _metal = require('metal');\n\nvar _validators = require('./validators');\n\nvar _validators2 = _interopRequireDefault(_validators);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Sugar api that can be used as an alternative for manually building `State`\n * configuration in the expected format. For example, instead of having\n * something like this:\n *\n * ```js\n * MyClass.STATE = {\n *   foo: {\n *     required: true,\n *     validator: validators.number,\n *     value: 13\n *   }\n * };\n * ```\n *\n * You could instead do:\n *\n * ```js\n * MyClass.STATE = {\n *   foo: Config.required().number().value(13)\n * };\n * ```\n */\nvar Config = {\n\t/**\n * An object that contains a validator function.\n * @typedef {!Object} ConfigWithValidator\n */\n\n\t/**\n  * Function that creates `State` object with an `any` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tany: setPrimitiveValidators('any'),\n\n\t/**\n  * Function that creates `State` object with an `array` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tarray: setPrimitiveValidators('array'),\n\n\t/**\n  * Function that creates `State` object with an `arrayOf` validator.\n  * @param {ConfigWithValidator} stateConfig `State` configuration object\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tarrayOf: setNestedValidators('arrayOf'),\n\n\t/**\n  * Function that creates `State` object with a `bool` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tbool: setPrimitiveValidators('bool'),\n\n\t/**\n  * Function that creates `State` object with a `func` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tfunc: setPrimitiveValidators('func'),\n\n\t/**\n  * Function that creates `State` object with an `instanceOf` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tinstanceOf: setExplicitValueValidators('instanceOf'),\n\n\t/**\n  * Function that creates `State` object with a `number` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tnumber: setPrimitiveValidators('number'),\n\n\t/**\n  * Function that creates `State` object with an `object` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tobject: setPrimitiveValidators('object'),\n\n\t/**\n  * Function that creates `State` object with an `objectOf` validator.\n  * @param {ConfigWithValidator} stateConfig `State` configuration object\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tobjectOf: setNestedValidators('objectOf'),\n\n\t/**\n  * Function that creates `State` object with an `oneOf` validator.\n  * @param {!Array} values `State` configuration object\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\toneOf: setExplicitValueValidators('oneOf'),\n\n\t/**\n  * Creates `State` configuration object with an `oneOfType` validator.\n  * @param {ConfigWithValidator[]} validatorArray Array of `State` configuration objects.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\toneOfType: function oneOfType(validatorArray) {\n\t\tvalidatorArray = validatorArray.map(function (configObj) {\n\t\t\treturn configObj.config.validator;\n\t\t});\n\n\t\treturn this.validator(_validators2.default.oneOfType(validatorArray));\n\t},\n\n\n\t/**\n  * Creates `State` configuration object with a `shapeOf` validator.\n  * @param {!Object.<string, ConfigWithValidator>} shapeObj Values being `State` configuration objects.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tshapeOf: function shapeOf(shapeObj) {\n\t\tshapeObj = destructShapeOfConfigs(shapeObj);\n\n\t\treturn this.validator(_validators2.default.shapeOf(shapeObj));\n\t},\n\n\n\t/**\n  * Function that creates `State` object with an `string` validator.\n  * @return {ConfigWithValidator} `State` configuration object.\n  */\n\tstring: setPrimitiveValidators('string'),\n\n\t/**\n  * Adds the `internal` flag to the `State` configuration.\n  * @param {boolean} required Flag to set \"internal\" to. True by default.\n  * @return {!Object} `State` configuration object.\n  */\n\tinternal: function internal() {\n\t\tvar _internal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\treturn mergeConfig(this, {\n\t\t\tinternal: _internal\n\t\t});\n\t},\n\n\n\t/**\n  * Adds the `required` flag to the `State` configuration.\n  * @param {boolean} required Flag to set \"required\" to. True by default.\n  * @return {!Object} `State` configuration object.\n  */\n\trequired: function required() {\n\t\tvar _required = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\treturn mergeConfig(this, {\n\t\t\trequired: _required\n\t\t});\n\t},\n\n\n\t/**\n  * Adds a setter to the `State` configuration.\n  * @param {!function()} setter\n  * @return {!Object} `State` configuration object.\n  */\n\tsetter: function setter(_setter) {\n\t\treturn mergeConfig(this, {\n\t\t\tsetter: _setter\n\t\t});\n\t},\n\n\n\t/**\n  * Adds a validator to the `State` configuration.\n  * @param {!function()} validator\n  * @return {!Object} `State` configuration object.\n  */\n\tvalidator: function validator(_validator) {\n\t\treturn mergeConfig(this, {\n\t\t\tvalidator: _validator\n\t\t});\n\t},\n\n\n\t/**\n  * Adds a default value to the `State` configuration.\n  * @param {*} value\n  * @return {!Object} `State` configuration object.\n  */\n\tvalue: function value(_value) {\n\t\treturn mergeConfig(this, {\n\t\t\tvalue: _value\n\t\t});\n\t},\n\n\n\t/**\n  * Adds a valueFn that will return a default value for the `State` configuration.\n  * @param {!function()} valueFn\n  * @return {!Object} `State` configuration object.\n  */\n\tvalueFn: function valueFn(_valueFn) {\n\t\treturn mergeConfig(this, {\n\t\t\tvalueFn: _valueFn\n\t\t});\n\t}\n};\n\n/**\n * Recursively sets validators for shapeOf.\n * @param {!Object} shape The shape of specific types.\n * @return {!Object} Shape object with validators as values.\n */\nfunction destructShapeOfConfigs(shape) {\n\tvar keys = Object.keys(shape);\n\n\tvar retShape = {};\n\n\tkeys.forEach(function (key) {\n\t\tvar value = shape[key];\n\n\t\tretShape[key] = value.config && value.config.validator ? value.config.validator : destructShapeOfConfigs(value);\n\t});\n\n\treturn retShape;\n}\n\n/**\n * Merges the given config object into the one that has been built so far.\n * @param {!Object} context The object calling this function.\n * @param {!Object} config The object to merge to the built config.\n * @return {!Object} The final object containing the built config.\n */\nfunction mergeConfig(context, config) {\n\tvar obj = context;\n\tif (obj === Config) {\n\t\tobj = Object.create(Config);\n\t\tobj.config = {};\n\t}\n\t_metal.object.mixin(obj.config, config);\n\treturn obj;\n}\n\n/**\n* Calls validators with provided argument.\n* @param {string} name The name of the validator.\n* @param {!function()}\n*/\nfunction setExplicitValueValidators(name) {\n\treturn function (arg) {\n\t\treturn this.validator(_validators2.default[name](arg));\n\t};\n}\n\n/**\n* Calls validators with a single nested config.\n* @param {string} name The name of the validator.\n* @return {!function()}\n*/\nfunction setNestedValidators(name) {\n\treturn function (arg) {\n\t\treturn this.validator(_validators2.default[name](arg.config.validator));\n\t};\n}\n\n/**\n* Adds primitive type validators to the config object.\n* @param {string} name The name of the validator.\n* @return {!function()}\n*/\nfunction setPrimitiveValidators(name) {\n\treturn function () {\n\t\treturn this.validator(_validators2.default[name]);\n\t};\n}\n\nexports.default = Config;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-state/lib/Config.js\n// module id = 38\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _metal = require('metal');\n\nvar _metalEvents = require('metal-events');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * State adds support for having object properties that can be watched for\n * changes, as well as configured with validators, setters and other options.\n * See the `configState` method for a complete list of available configuration\n * options for each state key.\n * @extends {EventEmitter}\n */\nvar State = function (_EventEmitter) {\n\t_inherits(State, _EventEmitter);\n\n\t/**\n  * Constructor function for `State`.\n  * @param {Object=} opt_config Optional config object with initial values to\n  *     set state properties to.\n  * @param {Object=} opt_obj Optional object that should hold the state\n  *     properties. If none is given, they will be added directly to `this`\n  *     instead.\n  * @param {Object=} opt_context Optional context to call functions (like\n  *     validators and setters) on. Defaults to `this`.\n  */\n\tfunction State(opt_config, opt_obj, opt_context) {\n\t\t_classCallCheck(this, State);\n\n\t\t/**\n   * Context to call functions (like validators and setters) on.\n   * @type {!Object}\n   * @protected\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).call(this));\n\n\t\t_this.context_ = opt_context || _this;\n\n\t\t/**\n   * Map of keys that can not be used as state keys.\n   * @type {Object<string, boolean>}\n   * @protected\n   */\n\t\t_this.keysBlacklist_ = null;\n\n\t\t/**\n   * Object that should hold the state properties.\n   * @type {!Object}\n   * @protected\n   */\n\t\t_this.obj_ = opt_obj || _this;\n\n\t\t_this.eventData_ = null;\n\n\t\t/**\n   * Object with information about the batch event that is currently\n   * scheduled, or null if none is.\n   * @type {Object}\n   * @protected\n   */\n\t\t_this.scheduledBatchData_ = null;\n\n\t\t/**\n   * Object that contains information about all this instance's state keys.\n   * @type {!Object<string, !Object>}\n   * @protected\n   */\n\t\t_this.stateInfo_ = {};\n\n\t\t_this.stateConfigs_ = {};\n\n\t\t_this.initialValues_ = _metal.object.mixin({}, opt_config);\n\n\t\t_this.setShouldUseFacade(true);\n\t\t_this.configStateFromStaticHint_();\n\n\t\tObject.defineProperty(_this.obj_, State.STATE_REF_KEY, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: _this\n\t\t});\n\t\treturn _this;\n\t}\n\n\t/**\n  * Logs an error if the given property is required but wasn't given.\n  * @param {string} name\n  * @protected\n  */\n\n\n\t_createClass(State, [{\n\t\tkey: 'assertGivenIfRequired_',\n\t\tvalue: function assertGivenIfRequired_(name) {\n\t\t\tvar config = this.stateConfigs_[name];\n\t\t\tif (config.required) {\n\t\t\t\tvar info = this.getStateInfo(name);\n\t\t\t\tvar value = info.state === State.KeyStates.INITIALIZED ? this.get(name) : this.initialValues_[name];\n\t\t\t\tif (!(0, _metal.isDefAndNotNull)(value)) {\n\t\t\t\t\tvar errorMessage = 'The property called \"' + name + '\" is required but didn\\'t receive a value.';\n\t\t\t\t\tif (this.shouldThrowValidationError()) {\n\t\t\t\t\t\tthrow new Error(errorMessage);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Logs an error if the `validatorReturn` is instance of `Error`.\n   * @param {*} validatorReturn\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'assertValidatorReturnInstanceOfError_',\n\t\tvalue: function assertValidatorReturnInstanceOfError_(validatorReturn) {\n\t\t\tif (validatorReturn instanceof Error) {\n\t\t\t\tif (this.shouldThrowValidationError()) {\n\t\t\t\t\tthrow validatorReturn;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('Warning: ' + validatorReturn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Checks that the given name is a valid state key name. If it's not, an error\n   * will be thrown.\n   * @param {string} name The name to be validated.\n   * @throws {Error}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'assertValidStateKeyName_',\n\t\tvalue: function assertValidStateKeyName_(name) {\n\t\t\tif (this.keysBlacklist_ && this.keysBlacklist_[name]) {\n\t\t\t\tthrow new Error('It\\'s not allowed to create a state key with the name \"' + name + '\".');\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Builds the property definition object for the specified state key.\n   * @param {string} name The name of the key.\n   * @return {!Object}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'buildKeyPropertyDef_',\n\t\tvalue: function buildKeyPropertyDef_(name) {\n\t\t\treturn {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn this[State.STATE_REF_KEY].getStateKeyValue_(name);\n\t\t\t\t},\n\t\t\t\tset: function set(val) {\n\t\t\t\t\tthis[State.STATE_REF_KEY].setStateKeyValue_(name, val);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Calls the requested function, running the appropriate code for when it's\n   * passed as an actual function object or just the function's name.\n   * @param {!Function|string} fn Function, or name of the function to run.\n   * @param {!Array} An optional array of parameters to be passed to the\n   *   function that will be called.\n   * @return {*} The return value of the called function.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'callFunction_',\n\t\tvalue: function callFunction_(fn, args) {\n\t\t\tif ((0, _metal.isString)(fn)) {\n\t\t\t\treturn this.context_[fn].apply(this.context_, args);\n\t\t\t} else if ((0, _metal.isFunction)(fn)) {\n\t\t\t\treturn fn.apply(this.context_, args);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Calls the state key's setter, if there is one.\n   * @param {string} name The name of the key.\n   * @param {*} value The value to be set.\n   * @param {*} currentValue The current value.\n   * @return {*} The final value to be set.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'callSetter_',\n\t\tvalue: function callSetter_(name, value, currentValue) {\n\t\t\tvar config = this.stateConfigs_[name];\n\t\t\tif (config.setter) {\n\t\t\t\tvalue = this.callFunction_(config.setter, [value, currentValue]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n   * Calls the state key's validator, if there is one. Emits console\n   * warning if validator returns a string.\n   * @param {string} name The name of the key.\n   * @param {*} value The value to be validated.\n   * @return {boolean} Flag indicating if value is valid or not.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'callValidator_',\n\t\tvalue: function callValidator_(name, value) {\n\t\t\tvar config = this.stateConfigs_[name];\n\t\t\tif (config.validator) {\n\t\t\t\tvar validatorReturn = this.callFunction_(config.validator, [value, name, this.context_]);\n\t\t\t\tthis.assertValidatorReturnInstanceOfError_(validatorReturn);\n\t\t\t\treturn validatorReturn;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n   * Checks if the it's allowed to write on the requested state key.\n   * @param {string} name The name of the key.\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'canSetState',\n\t\tvalue: function canSetState(name) {\n\t\t\tvar info = this.getStateInfo(name);\n\t\t\treturn !this.stateConfigs_[name].writeOnce || !info.written;\n\t\t}\n\n\t\t/**\n   * Adds the given key(s) to the state, together with its(their) configs.\n   * Config objects support the given settings:\n   *     required - When set to `true`, causes errors to be printed (via\n   *     `console.error`) if no value is given for the property.\n   *\n   *     setter - Function for normalizing state key values. It receives the new\n   *     value that was set, and returns the value that should be stored.\n   *\n   *     validator - Function that validates state key values. When it returns\n   *     false, the new value is ignored. When it returns an instance of Error,\n   *     it will emit the error to the console.\n   *\n   *     value - The default value for the state key. Note that setting this to\n   *     an object will cause all class instances to use the same reference to\n   *     the object. To have each instance use a different reference for objects,\n   *     use the `valueFn` option instead.\n   *\n   *     valueFn - A function that returns the default value for a state key.\n   *\n   *     writeOnce - Ignores writes to the state key after it's been first\n   *     written to. That is, allows writes only when setting the value for the\n   *     first time.\n   * @param {!Object.<string, !Object>|string} configs An object that maps\n   *     configuration options for keys to be added to the state.\n   * @param {boolean|Object|*=} opt_context The context where the added state\n   *     keys will be defined (defaults to `this`), or false if they shouldn't\n   *     be defined at all.\n   */\n\n\t}, {\n\t\tkey: 'configState',\n\t\tvalue: function configState(configs, opt_context) {\n\t\t\tvar names = Object.keys(configs);\n\t\t\tif (names.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (opt_context !== false) {\n\t\t\t\tvar props = {};\n\t\t\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\t\t\tvar name = names[i];\n\t\t\t\t\tthis.assertValidStateKeyName_(name);\n\t\t\t\t\tprops[name] = this.buildKeyPropertyDef_(name);\n\t\t\t\t}\n\t\t\t\tObject.defineProperties(opt_context || this.obj_, props);\n\t\t\t}\n\n\t\t\tthis.stateConfigs_ = configs;\n\t\t\tfor (var _i = 0; _i < names.length; _i++) {\n\t\t\t\tvar _name = names[_i];\n\t\t\t\tconfigs[_name] = configs[_name].config ? configs[_name].config : configs[_name];\n\t\t\t\tthis.assertGivenIfRequired_(names[_i]);\n\t\t\t\tthis.validateInitialValue_(names[_i]);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Adds state keys from super classes static hint `MyClass.STATE = {};`.\n   * @param {Object.<string, !Object>=} opt_config An object that maps all the\n   *     configurations for state keys.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'configStateFromStaticHint_',\n\t\tvalue: function configStateFromStaticHint_() {\n\t\t\tvar ctor = this.constructor;\n\t\t\tif (ctor !== State) {\n\t\t\t\tvar defineContext = void 0;\n\t\t\t\tif (this.obj_ === this) {\n\t\t\t\t\tdefineContext = ctor.hasConfiguredState_ ? false : ctor.prototype;\n\t\t\t\t\tctor.hasConfiguredState_ = true;\n\t\t\t\t}\n\t\t\t\tthis.configState(State.getStateStatic(ctor), defineContext);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * @inheritDoc\n   */\n\n\t}, {\n\t\tkey: 'disposeInternal',\n\t\tvalue: function disposeInternal() {\n\t\t\t_get(State.prototype.__proto__ || Object.getPrototypeOf(State.prototype), 'disposeInternal', this).call(this);\n\t\t\tthis.initialValues_ = null;\n\t\t\tthis.stateInfo_ = null;\n\t\t\tthis.stateConfigs_ = null;\n\t\t\tthis.scheduledBatchData_ = null;\n\t\t}\n\n\t\t/**\n   * Emits the state change batch event.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'emitBatchEvent_',\n\t\tvalue: function emitBatchEvent_() {\n\t\t\tif (!this.isDisposed()) {\n\t\t\t\tvar data = this.scheduledBatchData_;\n\t\t\t\tthis.scheduledBatchData_ = null;\n\t\t\t\tthis.context_.emit('stateChanged', data);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Returns the value of the requested state key.\n   * Note: this can and should be accomplished by accessing the value as a\n   * regular property. This should only be used in cases where a function is\n   * actually needed.\n   * @param {string} name\n   * @return {*}\n   */\n\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(name) {\n\t\t\treturn this.obj_[name];\n\t\t}\n\n\t\t/**\n   * Returns an object that maps state keys to their values.\n   * @param {Array<string>=} opt_names A list of names of the keys that should\n   *   be returned. If none is given, the whole state will be returned.\n   * @return {Object.<string, *>}\n   */\n\n\t}, {\n\t\tkey: 'getState',\n\t\tvalue: function getState(opt_names) {\n\t\t\tvar state = {};\n\t\t\tvar names = opt_names || this.getStateKeys();\n\n\t\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\t\tstate[names[i]] = this.get(names[i]);\n\t\t\t}\n\n\t\t\treturn state;\n\t\t}\n\n\t\t/**\n   * Gets information about the specified state property.\n   * @param {string} name\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getStateInfo',\n\t\tvalue: function getStateInfo(name) {\n\t\t\tif (!this.stateInfo_[name]) {\n\t\t\t\tthis.stateInfo_[name] = {};\n\t\t\t}\n\t\t\treturn this.stateInfo_[name];\n\t\t}\n\n\t\t/**\n   * Gets the config object for the requested state key.\n   * @param {string} name The key's name.\n   * @return {Object}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'getStateKeyConfig',\n\t\tvalue: function getStateKeyConfig(name) {\n\t\t\treturn this.stateConfigs_ ? this.stateConfigs_[name] : null;\n\t\t}\n\n\t\t/**\n   * Returns an array with all state keys.\n   * @return {!Array.<string>}\n   */\n\n\t}, {\n\t\tkey: 'getStateKeys',\n\t\tvalue: function getStateKeys() {\n\t\t\treturn this.stateConfigs_ ? Object.keys(this.stateConfigs_) : [];\n\t\t}\n\n\t\t/**\n   * Gets the value of the specified state key. This is passed as that key's\n   * getter to the `Object.defineProperty` call inside the `addKeyToState` method.\n   * @param {string} name The name of the key.\n   * @return {*}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'getStateKeyValue_',\n\t\tvalue: function getStateKeyValue_(name) {\n\t\t\tif (!this.warnIfDisposed_(name)) {\n\t\t\t\tthis.initStateKey_(name);\n\t\t\t\treturn this.getStateInfo(name).value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Merges the STATE static variable for the given constructor function.\n   * @param  {!Function} ctor Constructor function.\n   * @return {boolean} Returns true if merge happens, false otherwise.\n   * @static\n   */\n\n\t}, {\n\t\tkey: 'hasBeenSet',\n\n\n\t\t/**\n   * Checks if the value of the state key with the given name has already been\n   * set. Note that this doesn't run the key's getter.\n   * @param {string} name The name of the key.\n   * @return {boolean}\n   */\n\t\tvalue: function hasBeenSet(name) {\n\t\t\tvar info = this.getStateInfo(name);\n\t\t\treturn info.state === State.KeyStates.INITIALIZED || this.hasInitialValue_(name);\n\t\t}\n\n\t\t/**\n   * Checks if an initial value was given to the specified state property.\n   * @param {string} name The name of the key.\n   * @return {boolean}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'hasInitialValue_',\n\t\tvalue: function hasInitialValue_(name) {\n\t\t\treturn this.initialValues_.hasOwnProperty(name);\n\t\t}\n\n\t\t/**\n   * Checks if the given key is present in this instance's state.\n   * @param {string} key\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'hasStateKey',\n\t\tvalue: function hasStateKey(key) {\n\t\t\tif (!this.warnIfDisposed_(key)) {\n\t\t\t\treturn !!this.stateConfigs_[key];\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Informs of changes to a state key's value through an event. Won't trigger\n   * the event if the value hasn't changed or if it's being initialized.\n   * @param {string} name The name of the key.\n   * @param {*} prevVal The previous value of the key.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'informChange_',\n\t\tvalue: function informChange_(name, prevVal) {\n\t\t\tif (this.shouldInformChange_(name, prevVal)) {\n\t\t\t\tvar data = _metal.object.mixin({\n\t\t\t\t\tkey: name,\n\t\t\t\t\tnewVal: this.get(name),\n\t\t\t\t\tprevVal: prevVal\n\t\t\t\t}, this.eventData_);\n\t\t\t\tthis.context_.emit(name + 'Changed', data);\n\t\t\t\tthis.context_.emit('stateKeyChanged', data);\n\t\t\t\tthis.scheduleBatchEvent_(data);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Initializes the specified state key, giving it a first value.\n   * @param {string} name The name of the key.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'initStateKey_',\n\t\tvalue: function initStateKey_(name) {\n\t\t\tvar info = this.getStateInfo(name);\n\t\t\tif (info.state !== State.KeyStates.UNINITIALIZED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tinfo.state = State.KeyStates.INITIALIZING;\n\t\t\tthis.setInitialValue_(name);\n\t\t\tif (!info.written) {\n\t\t\t\tthis.setDefaultValue(name);\n\t\t\t}\n\t\t\tinfo.state = State.KeyStates.INITIALIZED;\n\t\t}\n\n\t\t/**\n   * Merges two values for the STATE property into a single object.\n   * @param {Object} mergedVal\n   * @param {Object} currVal\n   * @return {!Object} The merged value.\n   * @static\n   */\n\n\t}, {\n\t\tkey: 'removeStateKey',\n\n\n\t\t/**\n   * Removes the requested state key.\n   * @param {string} name The name of the key.\n   */\n\t\tvalue: function removeStateKey(name) {\n\t\t\tthis.stateInfo_[name] = null;\n\t\t\tthis.stateConfigs_[name] = null;\n\t\t\tdelete this.obj_[name];\n\t\t}\n\n\t\t/**\n   * Schedules a state change batch event to be emitted asynchronously.\n   * @param {!Object} changeData Information about a state key's update.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'scheduleBatchEvent_',\n\t\tvalue: function scheduleBatchEvent_(changeData) {\n\t\t\tif (!this.scheduledBatchData_) {\n\t\t\t\t_metal.async.nextTick(this.emitBatchEvent_, this);\n\t\t\t\tthis.scheduledBatchData_ = _metal.object.mixin({\n\t\t\t\t\tchanges: {}\n\t\t\t\t}, this.eventData_);\n\t\t\t}\n\n\t\t\tvar name = changeData.key;\n\t\t\tvar changes = this.scheduledBatchData_.changes;\n\t\t\tif (changes[name]) {\n\t\t\t\tchanges[name].newVal = changeData.newVal;\n\t\t\t} else {\n\t\t\t\tchanges[name] = changeData;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets the value of the requested state key.\n   * Note: this can and should be accomplished by setting the state key as a\n   * regular property. This should only be used in cases where a function is\n   * actually needed.\n   * @param {string} name\n   * @param {*} value\n   * @return {*}\n   */\n\n\t}, {\n\t\tkey: 'set',\n\t\tvalue: function set(name, value) {\n\t\t\tif (this.hasStateKey(name)) {\n\t\t\t\tthis.obj_[name] = value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets the default value of the requested state key.\n   * @param {string} name The name of the key.\n   * @return {*}\n   */\n\n\t}, {\n\t\tkey: 'setDefaultValue',\n\t\tvalue: function setDefaultValue(name) {\n\t\t\tvar config = this.stateConfigs_[name];\n\n\t\t\tif (config.value !== undefined) {\n\t\t\t\tthis.set(name, config.value);\n\t\t\t} else {\n\t\t\t\tthis.set(name, this.callFunction_(config.valueFn));\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets data to be sent with all events emitted from this instance.\n   * @param {Object}\n   */\n\n\t}, {\n\t\tkey: 'setEventData',\n\t\tvalue: function setEventData(data) {\n\t\t\tthis.eventData_ = data;\n\t\t}\n\n\t\t/**\n   * Sets the initial value of the requested state key.\n   * @param {string} name The name of the key.\n   * @return {*}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'setInitialValue_',\n\t\tvalue: function setInitialValue_(name) {\n\t\t\tif (this.hasInitialValue_(name)) {\n\t\t\t\tthis.set(name, this.initialValues_[name]);\n\t\t\t\tthis.initialValues_[name] = undefined;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets a map of keys that are not valid state keys.\n   * @param {!Object<string, boolean>}\n   */\n\n\t}, {\n\t\tkey: 'setKeysBlacklist',\n\t\tvalue: function setKeysBlacklist(blacklist) {\n\t\t\tthis.keysBlacklist_ = blacklist;\n\t\t}\n\n\t\t/**\n   * Sets the value of all the specified state keys.\n   * @param {!Object.<string,*>} values A map of state keys to the values they\n   *   should be set to.\n   * @param {function()=} opt_callback An optional function that will be run\n   *   after the next batched update is triggered.\n   */\n\n\t}, {\n\t\tkey: 'setState',\n\t\tvalue: function setState(values, opt_callback) {\n\t\t\tvar _this2 = this;\n\n\t\t\tObject.keys(values).forEach(function (name) {\n\t\t\t\treturn _this2.set(name, values[name]);\n\t\t\t});\n\t\t\tif (opt_callback && this.scheduledBatchData_) {\n\t\t\t\tthis.context_.once('stateChanged', opt_callback);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets the value of the specified state key. This is passed as that key's\n   * setter to the `Object.defineProperty` call inside the `addKeyToState`\n   * method.\n   * @param {string} name The name of the key.\n   * @param {*} value The new value of the key.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'setStateKeyValue_',\n\t\tvalue: function setStateKeyValue_(name, value) {\n\t\t\tif (this.warnIfDisposed_(name) || !this.canSetState(name) || !this.validateKeyValue_(name, value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar prevVal = this.get(name);\n\t\t\tvar info = this.getStateInfo(name);\n\t\t\tinfo.value = this.callSetter_(name, value, prevVal);\n\t\t\tthis.assertGivenIfRequired_(name);\n\t\t\tinfo.written = true;\n\t\t\tthis.informChange_(name, prevVal);\n\t\t}\n\n\t\t/**\n   * Checks if we should inform about a state update. Updates are ignored during\n   * state initialization. Otherwise, updates to primitive values are only\n   * informed when the new value is different from the previous one. Updates to\n   * objects (which includes functions and arrays) are always informed outside\n   * initialization though, since we can't be sure if all of the internal data\n   * has stayed the same.\n   * @param {string} name The name of the key.\n   * @param {*} prevVal The previous value of the key.\n   * @return {boolean}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'shouldInformChange_',\n\t\tvalue: function shouldInformChange_(name, prevVal) {\n\t\t\tvar info = this.getStateInfo(name);\n\t\t\treturn info.state === State.KeyStates.INITIALIZED && ((0, _metal.isObject)(prevVal) || prevVal !== this.get(name));\n\t\t}\n\n\t\t/**\n   * Returns a boolean that determines whether or not should throw error when\n   * vaildator functions returns an `Error` instance.\n   * @return {boolean} By default returns false.\n   */\n\n\t}, {\n\t\tkey: 'shouldThrowValidationError',\n\t\tvalue: function shouldThrowValidationError() {\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n   * Validates the initial value for the state property with the given name.\n   * @param {string} name\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'validateInitialValue_',\n\t\tvalue: function validateInitialValue_(name) {\n\t\t\tif (this.hasInitialValue_(name) && !this.callValidator_(name, this.initialValues_[name])) {\n\t\t\t\tdelete this.initialValues_[name];\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Validates the state key's value, which includes calling the validator\n   * defined in the key's configuration object, if there is one.\n   * @param {string} name The name of the key.\n   * @param {*} value The value to be validated.\n   * @return {boolean} Flag indicating if value is valid or not.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'validateKeyValue_',\n\t\tvalue: function validateKeyValue_(name, value) {\n\t\t\tvar info = this.getStateInfo(name);\n\t\t\treturn info.state === State.KeyStates.INITIALIZING || this.callValidator_(name, value);\n\t\t}\n\n\t\t/**\n   * Warns if this instance has already been disposed.\n   * @param {string} name Name of the property to be accessed if not disposed.\n   * @return {boolean} True if disposed, or false otherwise.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'warnIfDisposed_',\n\t\tvalue: function warnIfDisposed_(name) {\n\t\t\tvar disposed = this.isDisposed();\n\t\t\tif (disposed) {\n\t\t\t\tconsole.warn('Error. Trying to access property \"' + name + '\" on disposed instance');\n\t\t\t}\n\t\t\treturn disposed;\n\t\t}\n\t}], [{\n\t\tkey: 'getStateStatic',\n\t\tvalue: function getStateStatic(ctor) {\n\t\t\treturn (0, _metal.getStaticProperty)(ctor, 'STATE', State.mergeState);\n\t\t}\n\t}, {\n\t\tkey: 'mergeState',\n\t\tvalue: function mergeState(mergedVal, currVal) {\n\t\t\treturn _metal.object.mixin({}, currVal, mergedVal);\n\t\t}\n\t}]);\n\n\treturn State;\n}(_metalEvents.EventEmitter);\n\nState.STATE_REF_KEY = '__METAL_STATE_REF_KEY__';\n\n/**\n * Constants that represent the states that a state key can be in.\n * @type {!Object}\n */\nState.KeyStates = {\n\tUNINITIALIZED: undefined,\n\tINITIALIZING: 1,\n\tINITIALIZED: 2\n};\n\nexports.default = State;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-state/lib/State.js\n// module id = 39\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nvar _EventHandle = require('./EventHandle');\n\nvar _EventHandle2 = _interopRequireDefault(_EventHandle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar singleArray_ = [0];\n\n/**\n * EventEmitter utility.\n * @constructor\n * @extends {Disposable}\n */\n\nvar EventEmitter = function (_Disposable) {\n\t_inherits(EventEmitter, _Disposable);\n\n\tfunction EventEmitter() {\n\t\t_classCallCheck(this, EventEmitter);\n\n\t\t/**\n   * Holds event listeners scoped by event type.\n   * @type {Object<string, !Array<!function()>>}\n   * @protected\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (EventEmitter.__proto__ || Object.getPrototypeOf(EventEmitter)).call(this));\n\n\t\t_this.events_ = null;\n\n\t\t/**\n   * Handlers that are triggered when an event is listened to.\n   * @type {Array}\n   */\n\t\t_this.listenerHandlers_ = null;\n\n\t\t/**\n   * Configuration option which determines if an event facade should be sent\n   * as a param of listeners when emitting events. If set to true, the facade\n   * will be passed as the first argument of the listener.\n   * @type {boolean}\n   * @protected\n   */\n\t\t_this.shouldUseFacade_ = false;\n\t\treturn _this;\n\t}\n\n\t/**\n  * Adds a handler to given holder variable. If the holder doesn't have a\n  * value yet, it will receive the handler directly. If the holder is an array,\n  * the value will just be added to it. Otherwise, the holder will be set to a\n  * new array containing its previous value plus the new handler.\n  * @param {*} holder\n  * @param {!function()|Object} handler\n  * @return {*} The holder's new value.\n  * @protected\n  */\n\n\n\t_createClass(EventEmitter, [{\n\t\tkey: 'addHandler_',\n\t\tvalue: function addHandler_(holder, handler) {\n\t\t\tif (!holder) {\n\t\t\t\tholder = handler;\n\t\t\t} else {\n\t\t\t\tif (!Array.isArray(holder)) {\n\t\t\t\t\tholder = [holder];\n\t\t\t\t}\n\t\t\t\tholder.push(handler);\n\t\t\t}\n\t\t\treturn holder;\n\t\t}\n\n\t\t/**\n   * Adds a listener to the end of the listeners array for the specified events.\n   * @param {!(Array|string)} event\n   * @param {!Function} listener\n   * @param {boolean} opt_default Flag indicating if this listener is a default\n   *   action for this event. Default actions are run last, and only if no previous\n   *   listener call `preventDefault()` on the received event facade.\n   * @return {!EventHandle} Can be used to remove the listener.\n   */\n\n\t}, {\n\t\tkey: 'addListener',\n\t\tvalue: function addListener(event, listener, opt_default) {\n\t\t\tthis.validateListener_(listener);\n\n\t\t\tvar events = this.toEventsArray_(event);\n\t\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\t\tthis.addSingleListener_(events[i], listener, opt_default);\n\t\t\t}\n\n\t\t\treturn new _EventHandle2.default(this, event, listener);\n\t\t}\n\n\t\t/**\n   * Adds a listener to the end of the listeners array for a single event.\n   * @param {string} event\n   * @param {!Function} listener\n   * @param {boolean} opt_default Flag indicating if this listener is a default\n   *   action for this event. Default actions are run last, and only if no previous\n   *   listener call `preventDefault()` on the received event facade.\n   * @return {!EventHandle} Can be used to remove the listener.\n   * @param {Function=} opt_origin The original function that was added as a\n   *   listener, if there is any.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'addSingleListener_',\n\t\tvalue: function addSingleListener_(event, listener, opt_default, opt_origin) {\n\t\t\tthis.runListenerHandlers_(event);\n\t\t\tif (opt_default || opt_origin) {\n\t\t\t\tlistener = {\n\t\t\t\t\tdefault: opt_default,\n\t\t\t\t\tfn: listener,\n\t\t\t\t\torigin: opt_origin\n\t\t\t\t};\n\t\t\t}\n\t\t\tthis.events_ = this.events_ || {};\n\t\t\tthis.events_[event] = this.addHandler_(this.events_[event], listener);\n\t\t}\n\n\t\t/**\n   * Builds facade for the given event.\n   * @param {string} event\n   * @return {Object}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'buildFacade_',\n\t\tvalue: function buildFacade_(event) {\n\t\t\tif (this.getShouldUseFacade()) {\n\t\t\t\tvar facade = {\n\t\t\t\t\tpreventDefault: function preventDefault() {\n\t\t\t\t\t\tfacade.preventedDefault = true;\n\t\t\t\t\t},\n\t\t\t\t\ttarget: this,\n\t\t\t\t\ttype: event\n\t\t\t\t};\n\t\t\t\treturn facade;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Disposes of this instance's object references.\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'disposeInternal',\n\t\tvalue: function disposeInternal() {\n\t\t\tthis.events_ = null;\n\t\t}\n\n\t\t/**\n   * Execute each of the listeners in order with the supplied arguments.\n   * @param {string} event\n   * @param {*} opt_args [arg1], [arg2], [...]\n   * @return {boolean} Returns true if event had listeners, false otherwise.\n   */\n\n\t}, {\n\t\tkey: 'emit',\n\t\tvalue: function emit(event) {\n\t\t\tvar listeners = this.getRawListeners_(event);\n\t\t\tif (listeners.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar args = _metal.array.slice(arguments, 1);\n\t\t\tthis.runListeners_(listeners, args, this.buildFacade_(event));\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n   * Gets the listener objects for the given event, if there are any.\n   * @param {string} event\n   * @return {!Array}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'getRawListeners_',\n\t\tvalue: function getRawListeners_(event) {\n\t\t\tvar directListeners = toArray(this.events_ && this.events_[event]);\n\t\t\treturn directListeners.concat(toArray(this.events_ && this.events_['*']));\n\t\t}\n\n\t\t/**\n   * Gets the configuration option which determines if an event facade should\n   * be sent as a param of listeners when emitting events. If set to true, the\n   * facade will be passed as the first argument of the listener.\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'getShouldUseFacade',\n\t\tvalue: function getShouldUseFacade() {\n\t\t\treturn this.shouldUseFacade_;\n\t\t}\n\n\t\t/**\n   * Returns an array of listeners for the specified event.\n   * @param {string} event\n   * @return {Array} Array of listeners.\n   */\n\n\t}, {\n\t\tkey: 'listeners',\n\t\tvalue: function listeners(event) {\n\t\t\treturn this.getRawListeners_(event).map(function (listener) {\n\t\t\t\treturn listener.fn ? listener.fn : listener;\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Adds a listener that will be invoked a fixed number of times for the\n   * events. After each event is triggered the specified amount of times, the\n   * listener is removed for it.\n   * @param {!(Array|string)} event\n   * @param {number} amount The amount of times this event should be listened\n   * to.\n   * @param {!Function} listener\n   * @return {!EventHandle} Can be used to remove the listener.\n   */\n\n\t}, {\n\t\tkey: 'many',\n\t\tvalue: function many(event, amount, listener) {\n\t\t\tvar events = this.toEventsArray_(event);\n\t\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\t\tthis.many_(events[i], amount, listener);\n\t\t\t}\n\n\t\t\treturn new _EventHandle2.default(this, event, listener);\n\t\t}\n\n\t\t/**\n   * Adds a listener that will be invoked a fixed number of times for a single\n   * event. After the event is triggered the specified amount of times, the\n   * listener is removed.\n   * @param {string} event\n   * @param {number} amount The amount of times this event should be listened\n   * to.\n   * @param {!Function} listener\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'many_',\n\t\tvalue: function many_(event, amount, listener) {\n\t\t\tvar self = this;\n\n\t\t\tif (amount <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfunction handlerInternal() {\n\t\t\t\tif (--amount === 0) {\n\t\t\t\t\tself.removeListener(event, handlerInternal);\n\t\t\t\t}\n\t\t\t\tlistener.apply(self, arguments);\n\t\t\t}\n\n\t\t\tself.addSingleListener_(event, handlerInternal, false, listener);\n\t\t}\n\n\t\t/**\n   * Checks if a listener object matches the given listener function. To match,\n   * it needs to either point to that listener or have it as its origin.\n   * @param {!Object} listenerObj\n   * @param {!Function} listener\n   * @return {boolean}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'matchesListener_',\n\t\tvalue: function matchesListener_(listenerObj, listener) {\n\t\t\tvar fn = listenerObj.fn || listenerObj;\n\t\t\treturn fn === listener || listenerObj.origin && listenerObj.origin === listener;\n\t\t}\n\n\t\t/**\n   * Removes a listener for the specified events.\n   * Caution: changes array indices in the listener array behind the listener.\n   * @param {!(Array|string)} events\n   * @param {!Function} listener\n   * @return {!Object} Returns emitter, so calls can be chained.\n   */\n\n\t}, {\n\t\tkey: 'off',\n\t\tvalue: function off(event, listener) {\n\t\t\tthis.validateListener_(listener);\n\t\t\tif (!this.events_) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar events = this.toEventsArray_(event);\n\t\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\t\tthis.events_[events[i]] = this.removeMatchingListenerObjs_(toArray(this.events_[events[i]]), listener);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Adds a listener to the end of the listeners array for the specified events.\n   * @param {!(Array|string)} events\n   * @param {!Function} listener\n   * @return {!EventHandle} Can be used to remove the listener.\n   */\n\n\t}, {\n\t\tkey: 'on',\n\t\tvalue: function on() {\n\t\t\treturn this.addListener.apply(this, arguments);\n\t\t}\n\n\t\t/**\n   * Adds handler that gets triggered when an event is listened to on this\n   * instance.\n   * @param {!function()}\n   */\n\n\t}, {\n\t\tkey: 'onListener',\n\t\tvalue: function onListener(handler) {\n\t\t\tthis.listenerHandlers_ = this.addHandler_(this.listenerHandlers_, handler);\n\t\t}\n\n\t\t/**\n   * Adds a one time listener for the events. This listener is invoked only the\n   * next time each event is fired, after which it is removed.\n   * @param {!(Array|string)} events\n   * @param {!Function} listener\n   * @return {!EventHandle} Can be used to remove the listener.\n   */\n\n\t}, {\n\t\tkey: 'once',\n\t\tvalue: function once(events, listener) {\n\t\t\treturn this.many(events, 1, listener);\n\t\t}\n\n\t\t/**\n   * Removes all listeners, or those of the specified events. It's not a good\n   * idea to remove listeners that were added elsewhere in the code,\n   * especially when it's on an emitter that you didn't create.\n   * @param {(Array|string)=} opt_events\n   * @return {!Object} Returns emitter, so calls can be chained.\n   */\n\n\t}, {\n\t\tkey: 'removeAllListeners',\n\t\tvalue: function removeAllListeners(opt_events) {\n\t\t\tif (this.events_) {\n\t\t\t\tif (opt_events) {\n\t\t\t\t\tvar events = this.toEventsArray_(opt_events);\n\t\t\t\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\t\t\t\tthis.events_[events[i]] = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.events_ = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Removes all listener objects from the given array that match the given\n   * listener function.\n   * @param {Array.<Object>} listenerObjs\n   * @param {!Function} listener\n   * @return {Array.<Object>|Object} The new listeners array for this event.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'removeMatchingListenerObjs_',\n\t\tvalue: function removeMatchingListenerObjs_(listenerObjs, listener) {\n\t\t\tvar finalListeners = [];\n\t\t\tfor (var i = 0; i < listenerObjs.length; i++) {\n\t\t\t\tif (!this.matchesListener_(listenerObjs[i], listener)) {\n\t\t\t\t\tfinalListeners.push(listenerObjs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finalListeners.length > 0 ? finalListeners : null;\n\t\t}\n\n\t\t/**\n   * Removes a listener for the specified events.\n   * Caution: changes array indices in the listener array behind the listener.\n   * @param {!(Array|string)} events\n   * @param {!Function} listener\n   * @return {!Object} Returns emitter, so calls can be chained.\n   */\n\n\t}, {\n\t\tkey: 'removeListener',\n\t\tvalue: function removeListener() {\n\t\t\treturn this.off.apply(this, arguments);\n\t\t}\n\n\t\t/**\n   * Runs the handlers when an event is listened to.\n   * @param {string} event\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'runListenerHandlers_',\n\t\tvalue: function runListenerHandlers_(event) {\n\t\t\tvar handlers = this.listenerHandlers_;\n\t\t\tif (handlers) {\n\t\t\t\thandlers = toArray(handlers);\n\t\t\t\tfor (var i = 0; i < handlers.length; i++) {\n\t\t\t\t\thandlers[i](event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Runs the given listeners.\n   * @param {!Array} listeners\n   * @param {!Array} args\n   * @param (Object) facade\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'runListeners_',\n\t\tvalue: function runListeners_(listeners, args, facade) {\n\t\t\tif (facade) {\n\t\t\t\targs.push(facade);\n\t\t\t}\n\n\t\t\tvar defaultListeners = [];\n\t\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\t\tvar listener = listeners[i].fn || listeners[i];\n\t\t\t\tif (listeners[i].default) {\n\t\t\t\t\tdefaultListeners.push(listener);\n\t\t\t\t} else {\n\t\t\t\t\tlistener.apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!facade || !facade.preventedDefault) {\n\t\t\t\tfor (var j = 0; j < defaultListeners.length; j++) {\n\t\t\t\t\tdefaultListeners[j].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Sets the configuration option which determines if an event facade should\n   * be sent as a param of listeners when emitting events. If set to true, the\n   * facade will be passed as the first argument of the listener.\n   * @param {boolean} shouldUseFacade\n   * @return {!Object} Returns emitter, so calls can be chained.\n   */\n\n\t}, {\n\t\tkey: 'setShouldUseFacade',\n\t\tvalue: function setShouldUseFacade(shouldUseFacade) {\n\t\t\tthis.shouldUseFacade_ = shouldUseFacade;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Converts the parameter to an array if only one event is given. Reuses the\n   * same array each time this conversion is done, to avoid using more memory\n   * than necessary.\n   * @param  {!(Array|string)} events\n   * @return {!Array}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'toEventsArray_',\n\t\tvalue: function toEventsArray_(events) {\n\t\t\tif ((0, _metal.isString)(events)) {\n\t\t\t\tsingleArray_[0] = events;\n\t\t\t\tevents = singleArray_;\n\t\t\t}\n\t\t\treturn events;\n\t\t}\n\n\t\t/**\n   * Checks if the given listener is valid, throwing an exception when it's not.\n   * @param  {*} listener\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'validateListener_',\n\t\tvalue: function validateListener_(listener) {\n\t\t\tif (!(0, _metal.isFunction)(listener)) {\n\t\t\t\tthrow new TypeError('Listener must be a function');\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn EventEmitter;\n}(_metal.Disposable);\n\nfunction toArray(val) {\n\tval = val || [];\n\treturn Array.isArray(val) ? val : [val];\n}\n\nexports.default = EventEmitter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-events/lib/EventEmitter.js\n// module id = 40\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @param {EventEmitter} originEmitter Events originated on this emitter\n *   will be fired for the target emitter's listeners as well.\n * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n *   will also be triggered when the event is fired by the origin emitter.\n * @param {Object} opt_blacklist Optional blacklist of events that should not be\n *   proxied.\n * @constructor\n * @extends {Disposable}\n */\nvar EventEmitterProxy = function (_Disposable) {\n\t_inherits(EventEmitterProxy, _Disposable);\n\n\tfunction EventEmitterProxy(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {\n\t\t_classCallCheck(this, EventEmitterProxy);\n\n\t\t/**\n   * Map of events that should not be proxied.\n   * @type {Object}\n   * @protected\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (EventEmitterProxy.__proto__ || Object.getPrototypeOf(EventEmitterProxy)).call(this));\n\n\t\t_this.blacklist_ = opt_blacklist;\n\n\t\t/**\n   * The origin emitter. This emitter's events will be proxied through the\n   * target emitter.\n   * @type {EventEmitter}\n   * @protected\n   */\n\t\t_this.originEmitter_ = originEmitter;\n\n\t\t/**\n   * A list of events that are pending to be listened by an actual origin\n   * emitter. Events are stored here when the origin doesn't exist, so they\n   * can be set on a new origin when one is set.\n   * @type {Array}\n   * @protected\n   */\n\t\t_this.pendingEvents_ = null;\n\n\t\t/**\n   * Holds a map of events from the origin emitter that are already being proxied.\n   * @type {Object<string, !EventHandle>}\n   * @protected\n   */\n\t\t_this.proxiedEvents_ = null;\n\n\t\t/**\n   * The target emitter. This emitter will emit all events that come from\n   * the origin emitter.\n   * @type {EventEmitter}\n   * @protected\n   */\n\t\t_this.targetEmitter_ = targetEmitter;\n\n\t\t/**\n   * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n   * @type {Object}\n   * @protected\n   */\n\t\t_this.whitelist_ = opt_whitelist;\n\n\t\t_this.startProxy_();\n\t\treturn _this;\n\t}\n\n\t/**\n  * Adds the given listener for the given event.\n  * @param {string} event\n  * @param {!function()} listener\n  * @return {!EventHandle} The listened event's handle.\n  * @protected\n  */\n\n\n\t_createClass(EventEmitterProxy, [{\n\t\tkey: 'addListener_',\n\t\tvalue: function addListener_(event, listener) {\n\t\t\treturn this.originEmitter_.on(event, listener);\n\t\t}\n\n\t\t/**\n   * @inheritDoc\n   */\n\n\t}, {\n\t\tkey: 'disposeInternal',\n\t\tvalue: function disposeInternal() {\n\t\t\tthis.removeListeners_();\n\t\t\tthis.proxiedEvents_ = null;\n\t\t\tthis.originEmitter_ = null;\n\t\t\tthis.targetEmitter_ = null;\n\t\t}\n\n\t\t/**\n   * Emits the specified event type on the target emitter.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'emitOnTarget_',\n\t\tvalue: function emitOnTarget_() {\n\t\t\tthis.targetEmitter_.emit.apply(this.targetEmitter_, arguments);\n\t\t}\n\n\t\t/**\n   * Proxies the given event from the origin to the target emitter.\n   * @param {string} event\n   */\n\n\t}, {\n\t\tkey: 'proxyEvent',\n\t\tvalue: function proxyEvent(event) {\n\t\t\tif (this.shouldProxyEvent_(event)) {\n\t\t\t\tthis.tryToAddListener_(event);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Removes the proxy listener for all events.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'removeListeners_',\n\t\tvalue: function removeListeners_() {\n\t\t\tif (this.proxiedEvents_) {\n\t\t\t\tvar events = Object.keys(this.proxiedEvents_);\n\t\t\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\t\t\tthis.proxiedEvents_[events[i]].removeListener();\n\t\t\t\t}\n\t\t\t\tthis.proxiedEvents_ = null;\n\t\t\t}\n\t\t\tthis.pendingEvents_ = null;\n\t\t}\n\n\t\t/**\n   * Changes the origin emitter. This automatically detaches any events that\n   * were already being proxied from the previous emitter, and starts proxying\n   * them on the new emitter instead.\n   * @param {!EventEmitter} originEmitter\n   */\n\n\t}, {\n\t\tkey: 'setOriginEmitter',\n\t\tvalue: function setOriginEmitter(originEmitter) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar events = this.originEmitter_ && this.proxiedEvents_ ? Object.keys(this.proxiedEvents_) : this.pendingEvents_;\n\t\t\tthis.originEmitter_ = originEmitter;\n\t\t\tif (events) {\n\t\t\t\tthis.removeListeners_();\n\t\t\t\tevents.forEach(function (event) {\n\t\t\t\t\treturn _this2.proxyEvent(event);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Checks if the given event should be proxied.\n   * @param {string} event\n   * @return {boolean}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'shouldProxyEvent_',\n\t\tvalue: function shouldProxyEvent_(event) {\n\t\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.blacklist_ && this.blacklist_[event]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn !this.proxiedEvents_ || !this.proxiedEvents_[event];\n\t\t}\n\n\t\t/**\n   * Starts proxying all events from the origin to the target emitter.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'startProxy_',\n\t\tvalue: function startProxy_() {\n\t\t\tthis.targetEmitter_.onListener(this.proxyEvent.bind(this));\n\t\t}\n\n\t\t/**\n   * Adds a listener to the origin emitter, if it exists. Otherwise, stores\n   * the pending listener so it can be used on a future origin emitter.\n   * @param {string} event\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'tryToAddListener_',\n\t\tvalue: function tryToAddListener_(event) {\n\t\t\tif (this.originEmitter_) {\n\t\t\t\tthis.proxiedEvents_ = this.proxiedEvents_ || {};\n\t\t\t\tthis.proxiedEvents_[event] = this.addListener_(event, this.emitOnTarget_.bind(this, event));\n\t\t\t} else {\n\t\t\t\tthis.pendingEvents_ = this.pendingEvents_ || [];\n\t\t\t\tthis.pendingEvents_.push(event);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn EventEmitterProxy;\n}(_metal.Disposable);\n\nexports.default = EventEmitterProxy;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-events/lib/EventEmitterProxy.js\n// module id = 41\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * EventHandler utility. It's useful for easily removing a group of\n * listeners from different EventEmitter instances.\n * @constructor\n * @extends {Disposable}\n */\nvar EventHandler = function (_Disposable) {\n\t_inherits(EventHandler, _Disposable);\n\n\tfunction EventHandler() {\n\t\t_classCallCheck(this, EventHandler);\n\n\t\t/**\n   * An array that holds the added event handles, so the listeners can be\n   * removed later.\n   * @type {Array.<EventHandle>}\n   * @protected\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (EventHandler.__proto__ || Object.getPrototypeOf(EventHandler)).call(this));\n\n\t\t_this.eventHandles_ = [];\n\t\treturn _this;\n\t}\n\n\t/**\n  * Adds event handles to be removed later through the `removeAllListeners`\n  * method.\n  * @param {...(!EventHandle)} var_args\n  */\n\n\n\t_createClass(EventHandler, [{\n\t\tkey: 'add',\n\t\tvalue: function add() {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tthis.eventHandles_.push(arguments[i]);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Disposes of this instance's object references.\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'disposeInternal',\n\t\tvalue: function disposeInternal() {\n\t\t\tthis.eventHandles_ = null;\n\t\t}\n\n\t\t/**\n   * Removes all listeners that have been added through the `add` method.\n   */\n\n\t}, {\n\t\tkey: 'removeAllListeners',\n\t\tvalue: function removeAllListeners() {\n\t\t\tfor (var i = 0; i < this.eventHandles_.length; i++) {\n\t\t\t\tthis.eventHandles_[i].removeListener();\n\t\t\t}\n\n\t\t\tthis.eventHandles_ = [];\n\t\t}\n\t}]);\n\n\treturn EventHandler;\n}(_metal.Disposable);\n\nexports.default = EventHandler;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-events/lib/EventHandler.js\n// module id = 42\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _JSXComponent = require('./JSXComponent');\n\nvar _JSXComponent2 = _interopRequireDefault(_JSXComponent);\n\nvar _metalState = require('metal-state');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * JSXComponent that renders html passed in.\n * @class\n */\nvar DangerouslySetHTML = function (_Component) {\n\t_inherits(DangerouslySetHTML, _Component);\n\n\tfunction DangerouslySetHTML() {\n\t\t_classCallCheck(this, DangerouslySetHTML);\n\n\t\treturn _possibleConstructorReturn(this, (DangerouslySetHTML.__proto__ || Object.getPrototypeOf(DangerouslySetHTML)).apply(this, arguments));\n\t}\n\n\t_createClass(DangerouslySetHTML, [{\n\t\tkey: 'render',\n\n\t\t/**\n   * @return {Component}\n   */\n\t\tvalue: function render() {\n\t\t\tvar _props = this.props,\n\t\t\t    content = _props.content,\n\t\t\t    tag = _props.tag;\n\n\n\t\t\tIncrementalDOM.elementOpen(tag, null, null);\n\n\t\t\tvar node = IncrementalDOM.elementClose(tag);\n\n\t\t\tnode.innerHTML = content;\n\n\t\t\treturn node;\n\t\t}\n\t}]);\n\n\treturn DangerouslySetHTML;\n}(_JSXComponent2.default);\n\nDangerouslySetHTML.PROPS = {\n\tcontent: _metalState.Config.string(),\n\ttag: _metalState.Config.string().value('span')\n};\n\nexports.default = DangerouslySetHTML;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-jsx/lib/DangerouslySetHTML.js\n// module id = 43\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _metalIncrementalDom = require('metal-incremental-dom');\n\nvar _metalIncrementalDom2 = _interopRequireDefault(_metalIncrementalDom);\n\nvar _JSXRenderer = require('./JSXRenderer');\n\nvar _JSXRenderer2 = _interopRequireDefault(_JSXRenderer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * These helpers are all from \"babel-plugin-incremental-dom\". See its README\n * file for more details:\n * https://github.com/jridgewell/babel-plugin-incremental-dom#runtime\n */\n\nvar scope = typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window;\n\nscope.iDOMHelpers = scope.iDOMHelpers || {};\n\nscope.iDOMHelpers.attr = function (value, attrName) {\n\tIncrementalDOM.attr(attrName, value);\n};\n\nscope.iDOMHelpers.forOwn = function (object, iterator) {\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tfor (var prop in object) {\n\t\tif (hasOwn.call(object, prop)) {\n\t\t\titerator(object[prop], prop);\n\t\t}\n\t}\n};\n\nscope.iDOMHelpers.jsxWrapper = function (elementClosure, args) {\n\tvar wrapper = args ? function () {\n\t\treturn elementClosure.apply(this, args);\n\t} : elementClosure;\n\twrapper.__jsxDOMWrapper = true;\n\treturn wrapper;\n};\n\nscope.iDOMHelpers.renderArbitrary = function (child) {\n\tvar type = typeof child === 'undefined' ? 'undefined' : _typeof(child);\n\tif (type === 'number' || type === 'string' || child && child instanceof String) {\n\t\tIncrementalDOM.text(child);\n\t} else if (type === 'function' && child.__jsxDOMWrapper) {\n\t\tchild();\n\t} else if (Array.isArray(child)) {\n\t\tchild.forEach(scope.iDOMHelpers.renderArbitrary);\n\t} else if (String(child) === '[object Object]') {\n\t\t// Renders special incremental dom nodes in a special way :)\n\t\tif (_metalIncrementalDom2.default.isIncDomNode(child)) {\n\t\t\t_metalIncrementalDom2.default.renderChild(child);\n\t\t} else {\n\t\t\tscope.iDOMHelpers.forOwn(child, scope.iDOMHelpers.renderArbitrary);\n\t\t}\n\t} else if (!child) {\n\t\t_JSXRenderer2.default.skipChild();\n\t}\n};\n\nexports.default = scope.iDOMHelpers;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-jsx/lib/iDOMHelpers.js\n// module id = 44\n// module chunks = 0","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A constructor function that will create blank objects.\n * @constructor\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return new Blank();\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   * {boolean}\n   */\n  this.staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {!Object<string, !Element>}\n   */\n  this.keyMap = createMap();\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * @type {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   * @type {boolean}\n   */\n  this.focused = false;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {?Node} node The Node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  importNode(node);\n  return node['__incrementalDOMData'];\n};\n\n/**\n * Imports node and its subtree, initializing caches.\n *\n * @param {?Node} node The Node to import.\n */\nvar importNode = function (node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  var isElement = node instanceof Element;\n  var nodeName = isElement ? node.localName : node.nodeName;\n  var key = isElement ? node.getAttribute('key') : null;\n  var data = initData(node, nodeName, key);\n\n  if (key) {\n    getData(node.parentNode).keyMap[key] = node;\n  }\n\n  if (isElement) {\n    var attributes = node.attributes;\n    var attrs = data.attrs;\n    var newAttrs = data.newAttrs;\n    var attrsArr = data.attrsArr;\n\n    for (var i = 0; i < attributes.length; i += 1) {\n      var attr = attributes[i];\n      var name = attr.name;\n      var value = attr.value;\n\n      attrs[name] = value;\n      newAttrs[name] = undefined;\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (var child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n};\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nvar inAttributes = false;\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nvar inSkip = false;\n\n/**\n * Makes sure that there is a current patch context.\n * @param {string} functionName\n * @param {*} context\n */\nvar assertInPatch = function (functionName, context) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n};\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nvar assertNoUnclosedTags = function (openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  var currentElement = openElement;\n  var openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n};\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nvar assertNotInAttributes = function (functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nvar assertNotInSkip = function (functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');\n  }\n};\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nvar assertInAttributes = function (functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');\n  }\n};\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nvar assertVirtualAttributesClosed = function () {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');\n  }\n};\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nvar assertCloseMatchesOpenTag = function (nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close \"' + tag + '\" but \"' + nodeName + '\" was open.');\n  }\n};\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nvar assertNoChildrenDeclaredYet = function (functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');\n  }\n};\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} startNode The value for the currentNode when the patch\n *     started.\n * @param {?Node} currentNode The currentNode when the patch finished.\n * @param {?Node} expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param {?Node} expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nvar assertPatchElementNoExtras = function (startNode, currentNode, expectedNextNode, expectedPrevNode) {\n  var wasUpdated = currentNode.nextSibling === expectedNextNode && currentNode.previousSibling === expectedPrevNode;\n  var wasChanged = currentNode.nextSibling === startNode.nextSibling && currentNode.previousSibling === expectedPrevNode;\n  var wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');\n  }\n};\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInAttributes = function (value) {\n  var previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInSkip = function (value) {\n  var previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @param {!Node} node\n * @return {boolean} True if the node the root of a document, false otherwise.\n */\nvar isDocumentRoot = function (node) {\n  // For ShadowRoots, check if they are a DocumentFragment instead of if they\n  // are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are\n  // not supported.\n  return node instanceof Document || node instanceof DocumentFragment;\n};\n\n/**\n * @param {!Node} node The node to start at, inclusive.\n * @param {?Node} root The root ancestor to get until, exclusive.\n * @return {!Array<!Node>} The ancestry of DOM nodes.\n */\nvar getAncestry = function (node, root) {\n  var ancestry = [];\n  var cur = node;\n\n  while (cur !== root) {\n    ancestry.push(cur);\n    cur = cur.parentNode;\n  }\n\n  return ancestry;\n};\n\n/**\n * @param {!Node} node\n * @return {!Node} The root node of the DOM tree that contains node.\n */\nvar getRoot = function (node) {\n  var cur = node;\n  var prev = cur;\n\n  while (cur) {\n    prev = cur;\n    cur = cur.parentNode;\n  }\n\n  return prev;\n};\n\n/**\n * @param {!Node} node The node to get the activeElement for.\n * @return {?Element} The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nvar getActiveElement = function (node) {\n  var root = getRoot(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n};\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param {!Node} node The reference node to get the activeElement for.\n * @param {?Node} root The root to get the focused path until.\n * @return {!Array<Node>}\n */\nvar getFocusedPath = function (node, root) {\n  var activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n};\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param {?Node} parentNode\n * @param {!Node} node\n * @param {?Node} referenceNode\n */\nvar moveBefore = function (parentNode, node, referenceNode) {\n  var insertReferenceNode = node.nextSibling;\n  var cur = referenceNode;\n\n  while (cur !== node) {\n    var next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * @param {!Array<Node>} focusPath The nodes to mark.\n * @param {boolean} focused Whether or not they are focused.\n */\nvar markFocused = function (focusPath, focused) {\n  for (var i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n};\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @return {?Node} node\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    var focusPath = getFocusedPath(node, currentParent);\n    markFocused(focusPath, true);\n    var retVal = run(node, fn, data);\n    markFocused(focusPath, false);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertVirtualAttributesClosed();\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    context.notifyChanges();\n\n    context = prevContext;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n\n    return retVal;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {!Node} The patched node.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {?Node} The node if it was updated, its replacedment or null if it\n *     was removed.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  var startNode = /** @type {!Element} */{ nextSibling: node };\n  var expectedNextNode = null;\n  var expectedPrevNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);\n  }\n\n  if (node !== currentNode && node.parentNode) {\n    removeChild(currentParent, node, getData(currentParent).keyMap);\n  }\n\n  return startNode === currentNode ? null : currentNode;\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {!Node} matchNode A node to match the data to.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (matchNode, nodeName, key) {\n  var data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n */\nvar alignWithDOM = function (nodeName, key) {\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    return;\n  }\n\n  var parentData = getData(currentParent);\n  var currentNodeData = currentNode && getData(currentNode);\n  var keyMap = parentData.keyMap;\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    var keyNode = keyMap[key];\n    if (keyNode) {\n      if (matches(keyNode, nodeName, key)) {\n        node = keyNode;\n      } else if (keyNode === currentNode) {\n        context.markDeleted(keyNode);\n      } else {\n        removeChild(currentParent, keyNode, keyMap);\n      }\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key);\n    }\n\n    if (key) {\n      keyMap[key] = node;\n    }\n\n    context.markCreated(node);\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent, node, currentNode);\n  } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {\n    // Remove the currentNode, which can always be added back since we hold a\n    // reference through the keyMap. This prevents a large number of moves when\n    // a keyed item is removed or moved backwards in the DOM.\n    currentParent.replaceChild(node, currentNode);\n    parentData.keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * @param {?Node} node\n * @param {?Node} child\n * @param {?Object<string, !Element>} keyMap\n */\nvar removeChild = function (node, child, keyMap) {\n  node.removeChild(child);\n  context.markDeleted( /** @type {!Node}*/child);\n\n  var key = getData(child).key;\n  if (key) {\n    delete keyMap[key];\n  }\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  while (child !== currentNode) {\n    removeChild(node, child, keyMap);\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * @return {?Node} The next Node to be patched.\n */\nvar getNextNode = function () {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  currentNode = getNextNode();\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key) {\n  nextNode();\n  alignWithDOM(tag, key);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentElement', context);\n    assertNotInAttributes('currentElement');\n  }\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nvar currentPointer = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentPointer', context);\n    assertNotInAttributes('currentPointer');\n  }\n  return getNextNode();\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * Skips the next Node to be patched, moving the pointer forward to the next\n * sibling of the current pointer.\n */\nvar skipNode = nextNode;\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param {CSSStyleDeclaration} style\n * @param {!string} prop\n * @param {*} value\n */\nvar setStyleValue = function (style, prop, value) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, /** @type {string} */value);\n  } else {\n    style[prop] = value;\n  }\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        setStyleValue(elStyle, prop, obj[prop]);\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  var node = coreElementOpen(tag, key);\n  var data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (var _i = 0; _i < statics.length; _i += 2) {\n        var name = /** @type {string} */statics[_i];\n        var value = statics[_i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var isNew = !attrsArr.length;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    var _attr = arguments[i];\n    if (isNew) {\n      attrsArr[j] = _attr;\n      newAttrs[_attr] = undefined;\n    } else if (attrsArr[j] !== _attr) {\n      break;\n    }\n\n    var value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, _attr, value);\n    }\n  }\n\n  if (i < arguments.length || j < attrsArr.length) {\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    for (i = 0; i < attrsArr.length; i += 2) {\n      var name = /** @type {string} */attrsArr[i];\n      var value = attrsArr[i + 1];\n      newAttrs[name] = value;\n    }\n\n    for (var _attr2 in newAttrs) {\n      updateAttribute(node, _attr2, newAttrs[_attr2]);\n      newAttrs[_attr2] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  var node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.currentPointer = currentPointer;\nexports.skip = skip;\nexports.skipNode = skipNode;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\nexports.importNode = importNode;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/incremental-dom/dist/incremental-dom-cjs.js\n// module id = 45\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.IncrementalDOM = global.IncrementalDOM || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * An array used to store the strings generated by calls to\n * elementOpen, elementOpenStart, elementOpenEnd, elementEnd and elementVoid\n */\nexports.buffer = [];\n\n/** @type {?Object} */\nexports.currentParent = null;\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function currentElement() {\n  return exports.currentParent;\n};\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nvar currentPointer = function currentPointer() {\n  return {};\n};\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n *\n * @param {?object} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing open/close/etc. calls that\n *     describe the DOM. This should have at most one top level element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {void} Nothing.\n */\nvar patch = function patch(node, fn, data) {\n  exports.currentParent = node;\n  fn(data);\n  exports.currentParent.innerHTML = exports.buffer.join('');\n  exports.buffer = [];\n  return exports.currentParent;\n};\n\nvar patchOuter = patch;\nvar patchInner = patch;\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n *\n * @return {void} Nothing.\n */\nvar text = function text(value, var_args) {\n  var formatted = value;\n  for (var i = 1; i < arguments.length; i += 1) {\n    var fn = arguments[i];\n    formatted = fn(formatted);\n  }\n  exports.buffer.push(formatted);\n};\n\n/** @const */\nvar symbols = {\n  default: '__default'\n};\n\n/** @const */\nvar attributes = {};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Array.<string>} el Buffer to append element attributes.\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function updateAttribute(el, name, value) {\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n};\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = function (el, name, value) {\n  if (Array.isArray(el)) {\n    el.push(' ' + name + '=\"' + value + '\"');\n  }\n};\n\n/**\n * Truncates an array, removing items up until length.\n * @param {!Array<*>} arr The array to truncate.\n * @param {number} length The new length of the array.\n */\nvar truncateArray = function truncateArray(arr, length) {\n  while (arr.length > length) {\n    arr.pop();\n  }\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {!Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n * @return {void} Nothing.\n */\nvar attr = function attr(name, value) {\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} The Element's tag.\n * @return {void} Nothing.\n */\nvar elementClose = function elementClose(nameOrCtor) {\n  if (typeof nameOrCtor === 'function') {\n    new nameOrCtor();\n    return;\n  }\n  exports.buffer.push('</' + nameOrCtor + '>');\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n *\n * @param {string} The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {void} Nothing.\n */\nvar elementVoid = function elementVoid(nameOrCtor, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(nameOrCtor);\n};\n\n/**\n * @param {!string} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {void} Nothing.\n */\nvar elementOpen = function elementOpen(nameOrCtor, key, statics, var_args) {\n  if (typeof nameOrCtor === 'function') {\n    new nameOrCtor();\n    return exports.currentParent;\n  }\n\n  exports.buffer.push('<' + nameOrCtor);\n\n  if (statics) {\n    for (var _i = 0; _i < statics.length; _i += 2) {\n      var name = /** @type {string} */statics[_i];\n      var value = statics[_i + 1];\n      updateAttribute(exports.buffer, name, value);\n    }\n  }\n\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    var _name = arguments[i];\n    var _value = arguments[i + 1];\n    updateAttribute(exports.buffer, _name, _value);\n  }\n\n  exports.buffer.push('>');\n\n  return exports.currentParent;\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n *\n * @return {void} Nothing.\n */\nvar elementOpenEnd = function elementOpenEnd() {\n  elementOpen.apply(null, argsBuilder);\n  truncateArray(argsBuilder, 0);\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {void} Nothing.\n */\nvar elementOpenStart = function elementOpenStart(nameOrCtor, key, statics) {\n  argsBuilder[0] = nameOrCtor;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/**\n * Returns the constructred DOM string at this point.\n * @param {function} fn\n * @return {string} The constructed DOM string.\n */\nvar renderToString = function renderToString(fn) {\n  patch({}, fn);\n  return currentElement().innerHTML;\n};\n\nexports.currentElement = currentElement;\nexports.currentPointer = currentPointer;\nexports.patch = patch;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.text = text;\nexports.attr = attr;\nexports.elementClose = elementClose;\nexports.elementOpen = elementOpen;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpenStart = elementOpenStart;\nexports.elementVoid = elementVoid;\nexports.renderToString = renderToString;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.updateAttribute = updateAttribute;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/incremental-dom-string/dist/incremental-dom-string.js\n// module id = 46\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.getPatchingComponent = getPatchingComponent;\nexports.patch = patch;\n\nvar _metalDom = require('metal-dom');\n\nvar _data = require('../data');\n\nvar _render = require('./render');\n\nvar patchingComponents_ = [];\n\n/**\n * Guarantees that the component's element has a parent. That's necessary\n * when calling incremental dom's `patchOuter` for now, as otherwise it will\n * throw an error if the element needs to be replaced.\n * @return {Element} The parent, in case it was added.\n * @private\n */\nfunction buildParentIfNecessary_(element) {\n\tif (!element || !element.parentNode) {\n\t\tvar parent = document.createElement('div');\n\t\tif (element) {\n\t\t\t(0, _metalDom.append)(parent, element);\n\t\t}\n\t\treturn parent;\n\t}\n}\n\n/**\n * Calls incremental dom's patch function.\n * @param {!Component} component The component to patch.\n * @param {!Element} element The element the component should be patched on.\n * @param {boolean=} opt_outer Flag indicating if `patchOuter` should be used\n *     instead of `patch`.\n * @private\n */\nfunction callPatch_(component, element, opt_outer) {\n\tpatchingComponents_.push(component);\n\n\tvar data = (0, _data.getData)(component);\n\tif (!data.render) {\n\t\t// Store reference to avoid binds on every patch.\n\t\tdata.render = _render.render.bind(null, component);\n\t}\n\n\tvar patchFn = opt_outer ? IncrementalDOM.patchOuter : IncrementalDOM.patch;\n\tpatchFn(element, data.render);\n\n\tpatchingComponents_.pop();\n}\n\n/**\n * Gets the component that triggered the current patch operation.\n * @return {Component}\n */\nfunction getPatchingComponent() {\n\treturn patchingComponents_[patchingComponents_.length - 1];\n}\n\n/**\n * Patches the component with incremental dom function calls.\n * @param {!Component} component\n */\nfunction patch(component) {\n\tif (!tryPatchEmptyWithParent_(component)) {\n\t\tif (!tryPatchWithNoParent_(component)) {\n\t\t\tvar element = component.element;\n\t\t\tcallPatch_(component, element, true);\n\t\t}\n\t}\n}\n\n/**\n * Checks if the component has no content but was rendered from another\n * component. If so, we'll need to patch this parent to make sure that any new\n * content will be added in the right position.\n * @param {!Component} component\n * @return {?boolean} True if the patch happened. Nothing otherwise.\n * @private\n */\nfunction tryPatchEmptyWithParent_(component) {\n\tvar data = (0, _data.getData)(component);\n\tif (!component.element && data.parent) {\n\t\tdata.parent.getRenderer().patch(data.parent);\n\t\treturn true;\n\t}\n}\n\n/**\n * Checks if the component's element exists and has a parent. If that's not the\n * case, a temporary parent will be created and passed to the `patch` function,\n * since incremental dom requires it. Once the patch is done the temporary\n * parent is removed and the component's content is reattached to the correct\n * final position.\n * @param {!Component} component\n * @return {?boolean} True if the patch happened. Nothing otherwise.\n * @private\n */\nfunction tryPatchWithNoParent_(component) {\n\tvar tempParent = buildParentIfNecessary_(component.element);\n\tif (tempParent) {\n\t\tcallPatch_(component, tempParent);\n\t\t(0, _metalDom.exitDocument)(component.element);\n\t\tif (component.element && component.inDocument) {\n\t\t\tvar attach = component.getAttachData();\n\t\t\tcomponent.attachElement(attach.parent, attach.sibling);\n\t\t}\n\t\treturn true;\n\t}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/render/patch.js\n// module id = 47\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.customEvents = undefined;\nexports.addClasses = addClasses;\nexports.closest = closest;\nexports.append = append;\nexports.buildFragment = buildFragment;\nexports.contains = contains;\nexports.delegate = delegate;\nexports.enterDocument = enterDocument;\nexports.exitDocument = exitDocument;\nexports.hasClass = hasClass;\nexports.isEmpty = isEmpty;\nexports.match = match;\nexports.next = next;\nexports.on = on;\nexports.once = once;\nexports.parent = parent;\nexports.registerCustomEvent = registerCustomEvent;\nexports.removeChildren = removeChildren;\nexports.removeClasses = removeClasses;\nexports.replace = replace;\nexports.supportsEvent = supportsEvent;\nexports.toElement = toElement;\nexports.toggleClasses = toggleClasses;\nexports.triggerEvent = triggerEvent;\n\nvar _metal = require('metal');\n\nvar _domData = require('./domData');\n\nvar _domData2 = _interopRequireDefault(_domData);\n\nvar _DomDelegatedEventHandle = require('./DomDelegatedEventHandle');\n\nvar _DomDelegatedEventHandle2 = _interopRequireDefault(_DomDelegatedEventHandle);\n\nvar _DomEventHandle = require('./DomEventHandle');\n\nvar _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar elementsByTag_ = {};\nvar supportCache_ = {};\nvar customEvents = exports.customEvents = {};\n\nvar LAST_CONTAINER = '__metal_last_container__';\nvar USE_CAPTURE = {\n\tblur: true,\n\terror: true,\n\tfocus: true,\n\tinvalid: true,\n\tload: true,\n\tscroll: true\n};\n\n/**\n * Adds the requested CSS classes to an element.\n * @param {!Element|!Nodelist} elements The element or elements to add CSS classes to.\n * @param {string} classes CSS classes to add.\n */\nfunction addClasses(elements, classes) {\n\tif (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {\n\t\treturn;\n\t}\n\n\tif (!elements.length) {\n\t\telements = [elements];\n\t}\n\n\tfor (var i = 0; i < elements.length; i++) {\n\t\tif ('classList' in elements[i]) {\n\t\t\taddClassesWithNative_(elements[i], classes);\n\t\t} else {\n\t\t\taddClassesWithoutNative_(elements[i], classes);\n\t\t}\n\t}\n}\n\n/**\n * Adds the requested CSS classes to an element using classList.\n * @param {!Element} element The element to add CSS classes to.\n * @param {string} classes CSS classes to add.\n * @private\n */\nfunction addClassesWithNative_(element, classes) {\n\tclasses.split(' ').forEach(function (className) {\n\t\tif (className) {\n\t\t\telement.classList.add(className);\n\t\t}\n\t});\n}\n\n/**\n * Adds the requested CSS classes to an element without using classList.\n * @param {!Element} element The element to add CSS classes to.\n * @param {string} classes CSS classes to add.\n * @private\n */\nfunction addClassesWithoutNative_(element, classes) {\n\tvar elementClassName = ' ' + element.className + ' ';\n\tvar classesToAppend = '';\n\n\tclasses = classes.split(' ');\n\n\tfor (var i = 0; i < classes.length; i++) {\n\t\tvar className = classes[i];\n\n\t\tif (elementClassName.indexOf(' ' + className + ' ') === -1) {\n\t\t\tclassesToAppend += ' ' + className;\n\t\t}\n\t}\n\n\tif (classesToAppend) {\n\t\telement.className = element.className + classesToAppend;\n\t}\n}\n\n/**\n * Adds an event listener to the given element, to be triggered via delegate.\n * @param {!Element} element\n * @param {string} eventName\n * @param {!function()} listener\n * @private\n */\nfunction addElementListener_(element, eventName, listener) {\n\taddToArr_(_domData2.default.get(element, 'listeners', {}), eventName, listener);\n}\n\n/**\n * Adds an event listener to the given element, to be triggered via delegate\n * selectors.\n * @param {!Element} element\n * @param {string} eventName\n * @param {string} selector\n * @param {!function()} listener\n * @private\n */\nfunction addSelectorListener_(element, eventName, selector, listener) {\n\tvar delegatingData = _domData2.default.get(element, 'delegating', {});\n\taddToArr_(delegatingData[eventName].selectors, selector, listener);\n}\n\n/**\n * Adds a value to an array inside an object, creating it first if it doesn't\n * yet exist.\n * @param {!Array} arr\n * @param {string} key\n * @param {*} value\n * @private\n */\nfunction addToArr_(arr, key, value) {\n\tif (!arr[key]) {\n\t\tarr[key] = [];\n\t}\n\tarr[key].push(value);\n}\n\n/**\n * Attaches a delegate listener, unless there's already one attached.\n * @param {!Element} element\n * @param {string} eventName\n * @private\n */\nfunction attachDelegateEvent_(element, eventName) {\n\tvar delegatingData = _domData2.default.get(element, 'delegating', {});\n\tif (!delegatingData[eventName]) {\n\t\tdelegatingData[eventName] = {\n\t\t\thandle: on(element, eventName, handleDelegateEvent_, !!USE_CAPTURE[eventName]),\n\t\t\tselectors: {}\n\t\t};\n\t}\n}\n\n/**\n * Gets the closest element up the tree from the given element (including\n * itself) that matches the specified selector, or null if none match.\n * @param {Element} element\n * @param {string} selector\n * @return {Element}\n */\nfunction closest(element, selector) {\n\twhile (element && !match(element, selector)) {\n\t\telement = element.parentNode;\n\t}\n\treturn element;\n}\n\n/**\n * Appends a child node with text or other nodes to a parent node. If\n * child is a HTML string it will be automatically converted to a document\n * fragment before appending it to the parent.\n * @param {!Element} parent The node to append nodes to.\n * @param {!(Element|NodeList|string)} child The thing to append to the parent.\n * @return {!Element} The appended child.\n */\nfunction append(parent, child) {\n\tif ((0, _metal.isString)(child)) {\n\t\tchild = buildFragment(child);\n\t}\n\tif (child instanceof NodeList) {\n\t\tvar childArr = Array.prototype.slice.call(child);\n\t\tfor (var i = 0; i < childArr.length; i++) {\n\t\t\tparent.appendChild(childArr[i]);\n\t\t}\n\t} else {\n\t\tparent.appendChild(child);\n\t}\n\treturn child;\n}\n\n/**\n * Helper for converting a HTML string into a document fragment.\n * @param {string} htmlString The HTML string to convert.\n * @return {!Element} The resulting document fragment.\n */\nfunction buildFragment(htmlString) {\n\tvar tempDiv = document.createElement('div');\n\ttempDiv.innerHTML = '<br>' + htmlString;\n\ttempDiv.removeChild(tempDiv.firstChild);\n\n\tvar fragment = document.createDocumentFragment();\n\twhile (tempDiv.firstChild) {\n\t\tfragment.appendChild(tempDiv.firstChild);\n\t}\n\treturn fragment;\n}\n\n/**\n * Checks if the first element contains the second one.\n * @param {!Element} element1\n * @param {!Element} element2\n * @return {boolean}\n */\nfunction contains(element1, element2) {\n\tif ((0, _metal.isDocument)(element1)) {\n\t\t// document.contains is not defined on IE9, so call it on documentElement instead.\n\t\treturn element1.documentElement.contains(element2);\n\t} else {\n\t\treturn element1.contains(element2);\n\t}\n}\n\n/**\n * Listens to the specified event on the given DOM element, but only calls the\n * given callback listener when it's triggered by elements that match the\n * given selector or target element.\n * @param {!Element} element The DOM element the event should be listened on.\n * @param {string} eventName The name of the event to listen to.\n * @param {!Element|string} selectorOrTarget Either an element or css selector\n *     that should match the event for the listener to be triggered.\n * @param {!function(!Object)} callback Function to be called when the event\n *     is triggered. It will receive the normalized event object.\n * @param {boolean=} opt_default Optional flag indicating if this is a default\n *     listener. That means that it would only be executed after all non\n *     default listeners, and only if the event isn't prevented via\n *     `preventDefault`.\n * @return {!EventHandle} Can be used to remove the listener.\n */\nfunction delegate(element, eventName, selectorOrTarget, callback, opt_default) {\n\tvar customConfig = customEvents[eventName];\n\tif (customConfig && customConfig.delegate) {\n\t\teventName = customConfig.originalEvent;\n\t\tcallback = customConfig.handler.bind(customConfig, callback);\n\t}\n\n\tif (opt_default) {\n\t\t// Wrap callback so we don't set property directly on it.\n\t\tcallback = callback.bind();\n\t\tcallback.defaultListener_ = true;\n\t}\n\n\tattachDelegateEvent_(element, eventName);\n\tif ((0, _metal.isString)(selectorOrTarget)) {\n\t\taddSelectorListener_(element, eventName, selectorOrTarget, callback);\n\t} else {\n\t\taddElementListener_(selectorOrTarget, eventName, callback);\n\t}\n\n\treturn new _DomDelegatedEventHandle2.default((0, _metal.isString)(selectorOrTarget) ? element : selectorOrTarget, eventName, callback, (0, _metal.isString)(selectorOrTarget) ? selectorOrTarget : null);\n}\n\n/**\n * Verifies if the element is able to trigger the Click event,\n * simulating browsers behaviour, avoiding event listeners to be called by triggerEvent method.\n * @param {Element} node Element to be checked.\n * @param {string} eventName The event name.\n * @private\n */\nfunction isAbleToInteractWith_(node, eventName, opt_eventObj) {\n\tif (opt_eventObj && eventName === 'click' && opt_eventObj.button === 2) {\n\t\t// Firefox triggers \"click\" events on the document for right clicks. This\n\t\t// causes our delegate logic to trigger it for regular elements too, which\n\t\t// shouldn't happen. Ignoring them here.\n\t\treturn false;\n\t}\n\n\tvar matchesSelector = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FIELDSET'];\n\tif (eventName === 'click' && matchesSelector.indexOf(node.tagName) > -1) {\n\t\treturn !(node.disabled || parent(node, 'fieldset[disabled]'));\n\t}\n\treturn true;\n}\n\n/**\n * Inserts node in document as last element.\n * @param {Element} node Element to remove children from.\n */\nfunction enterDocument(node) {\n\tnode && append(document.body, node);\n}\n\n/**\n * Removes node from document.\n * @param {Element} node Element to remove children from.\n */\nfunction exitDocument(node) {\n\tif (node && node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * This is called when an event is triggered by a delegate listener. All\n * matching listeners of this event type from `target` to `currentTarget` will\n * be triggered.\n * @param {!Event} event The event payload.\n * @return {boolean} False if at least one of the triggered callbacks returns\n *     false, or true otherwise.\n * @private\n */\nfunction handleDelegateEvent_(event) {\n\tnormalizeDelegateEvent_(event);\n\tvar ret = true;\n\tvar container = event.currentTarget;\n\tvar defFns = [];\n\n\tret &= triggerDelegatedListeners_(container, event, defFns);\n\tret &= triggerDefaultDelegatedListeners_(defFns, event);\n\n\tevent.delegateTarget = null;\n\tevent[LAST_CONTAINER] = container;\n\treturn ret;\n}\n\n/**\n * Checks if the given element has the requested css class.\n * @param {!Element} element\n * @param {string} className\n * @return {boolean}\n */\nfunction hasClass(element, className) {\n\tif ('classList' in element) {\n\t\treturn hasClassWithNative_(element, className);\n\t} else {\n\t\treturn hasClassWithoutNative_(element, className);\n\t}\n}\n\n/**\n * Checks if the given element has the requested css class using classList.\n * @param {!Element} element\n * @param {string} className\n * @return {boolean}\n * @private\n */\nfunction hasClassWithNative_(element, className) {\n\treturn element.classList.contains(className);\n}\n\n/**\n * Checks if the given element has the requested css class without using classList.\n * @param {!Element} element\n * @param {string} className\n * @return {boolean}\n * @private\n */\nfunction hasClassWithoutNative_(element, className) {\n\treturn (' ' + element.className + ' ').indexOf(' ' + className + ' ') >= 0;\n}\n\n/**\n * Checks if the given element is empty or not.\n * @param {!Element} element\n * @return {boolean}\n */\nfunction isEmpty(element) {\n\treturn element.childNodes.length === 0;\n}\n\n/**\n * Check if an element matches a given selector.\n * @param {Element} element\n * @param {string} selector\n * @return {boolean}\n */\nfunction match(element, selector) {\n\tif (!element || element.nodeType !== 1) {\n\t\treturn false;\n\t}\n\n\tvar p = Element.prototype;\n\tvar m = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;\n\tif (m) {\n\t\treturn m.call(element, selector);\n\t}\n\n\treturn matchFallback_(element, selector);\n}\n\n/**\n * Check if an element matches a given selector, using an internal implementation\n * instead of calling existing javascript functions.\n * @param {Element} element\n * @param {string} selector\n * @return {boolean}\n * @private\n */\nfunction matchFallback_(element, selector) {\n\tvar nodes = document.querySelectorAll(selector, element.parentNode);\n\tfor (var i = 0; i < nodes.length; ++i) {\n\t\tif (nodes[i] === element) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Returns the next sibling of the given element that matches the specified\n * selector, or null if there is none.\n * @param {!Element} element\n * @param {?string} selector\n */\nfunction next(element, selector) {\n\tdo {\n\t\telement = element.nextSibling;\n\t\tif (element && match(element, selector)) {\n\t\t\treturn element;\n\t\t}\n\t} while (element);\n\treturn null;\n}\n\n/**\n * Normalizes the event payload for delegate listeners.\n * @param {!Event} event\n * @private\n */\nfunction normalizeDelegateEvent_(event) {\n\tevent.stopPropagation = stopPropagation_;\n\tevent.stopImmediatePropagation = stopImmediatePropagation_;\n}\n\n/**\n * Listens to the specified event on the given DOM element. This function normalizes\n * DOM event payloads and functions so they'll work the same way on all supported\n * browsers.\n * @param {!Element|string} element The DOM element to listen to the event on, or\n *   a selector that should be delegated on the entire document.\n * @param {string} eventName The name of the event to listen to.\n * @param {!function(!Object)} callback Function to be called when the event is\n *   triggered. It will receive the normalized event object.\n * @param {boolean} opt_capture Flag indicating if listener should be triggered\n *   during capture phase, instead of during the bubbling phase. Defaults to false.\n * @return {!DomEventHandle} Can be used to remove the listener.\n */\nfunction on(element, eventName, callback, opt_capture) {\n\tif ((0, _metal.isString)(element)) {\n\t\treturn delegate(document, eventName, element, callback);\n\t}\n\tvar customConfig = customEvents[eventName];\n\tif (customConfig && customConfig.event) {\n\t\teventName = customConfig.originalEvent;\n\t\tcallback = customConfig.handler.bind(customConfig, callback);\n\t}\n\telement.addEventListener(eventName, callback, opt_capture);\n\treturn new _DomEventHandle2.default(element, eventName, callback, opt_capture);\n}\n\n/**\n * Listens to the specified event on the given DOM element once. This\n * function normalizes DOM event payloads and functions so they'll work the\n * same way on all supported browsers.\n * @param {!Element} element The DOM element to listen to the event on.\n * @param {string} eventName The name of the event to listen to.\n * @param {!function(!Object)} callback Function to be called when the event\n *   is triggered. It will receive the normalized event object.\n * @return {!DomEventHandle} Can be used to remove the listener.\n */\nfunction once(element, eventName, callback) {\n\tvar domEventHandle = on(element, eventName, function () {\n\t\tdomEventHandle.removeListener();\n\t\treturn callback.apply(this, arguments);\n\t});\n\treturn domEventHandle;\n}\n\n/**\n * Gets the first parent from the given element that matches the specified\n * selector, or null if none match.\n * @param {!Element} element\n * @param {string} selector\n * @return {Element}\n */\nfunction parent(element, selector) {\n\treturn closest(element.parentNode, selector);\n}\n\n/**\n * Registers a custom event.\n * @param {string} eventName The name of the custom event.\n * @param {!Object} customConfig An object with information about how the event\n *   should be handled.\n */\nfunction registerCustomEvent(eventName, customConfig) {\n\tcustomEvents[eventName] = customConfig;\n}\n\n/**\n * Removes all the child nodes on a DOM node.\n * @param {Element} node Element to remove children from.\n */\nfunction removeChildren(node) {\n\tvar child = void 0;\n\twhile (child = node.firstChild) {\n\t\tnode.removeChild(child);\n\t}\n}\n\n/**\n * Removes the requested CSS classes from an element.\n * @param {!Element|!NodeList} elements The element or elements to remove CSS classes from.\n * @param {string} classes CSS classes to remove.\n */\nfunction removeClasses(elements, classes) {\n\tif (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {\n\t\treturn;\n\t}\n\n\tif (!elements.length) {\n\t\telements = [elements];\n\t}\n\n\tfor (var i = 0; i < elements.length; i++) {\n\t\tif ('classList' in elements[i]) {\n\t\t\tremoveClassesWithNative_(elements[i], classes);\n\t\t} else {\n\t\t\tremoveClassesWithoutNative_(elements[i], classes);\n\t\t}\n\t}\n}\n\n/**\n * Removes the requested CSS classes from an element using classList.\n * @param {!Element} element The element to remove CSS classes from.\n * @param {string} classes CSS classes to remove.\n * @private\n */\nfunction removeClassesWithNative_(element, classes) {\n\tclasses.split(' ').forEach(function (className) {\n\t\tif (className) {\n\t\t\telement.classList.remove(className);\n\t\t}\n\t});\n}\n\n/**\n * Removes the requested CSS classes from an element without using classList.\n * @param {!Element} element The element to remove CSS classes from.\n * @param {string} classes CSS classes to remove.\n * @private\n */\nfunction removeClassesWithoutNative_(element, classes) {\n\tvar elementClassName = ' ' + element.className + ' ';\n\n\tclasses = classes.split(' ');\n\n\tfor (var i = 0; i < classes.length; i++) {\n\t\telementClassName = elementClassName.replace(' ' + classes[i] + ' ', ' ');\n\t}\n\n\telement.className = elementClassName.trim();\n}\n\n/**\n * Replaces the first element with the second.\n * @param {Element} element1\n * @param {Element} element2\n */\nfunction replace(element1, element2) {\n\tif (element1 && element2 && element1 !== element2 && element1.parentNode) {\n\t\telement1.parentNode.insertBefore(element2, element1);\n\t\telement1.parentNode.removeChild(element1);\n\t}\n}\n\n/**\n * The function that replaces `stopImmediatePropagation_` for events.\n * @private\n */\nfunction stopImmediatePropagation_() {\n\tvar event = this; // eslint-disable-line\n\tevent.stopped = true;\n\tevent.stoppedImmediate = true;\n\tEvent.prototype.stopImmediatePropagation.call(event);\n}\n\n/**\n * The function that replaces `stopPropagation` for events.\n * @private\n */\nfunction stopPropagation_() {\n\tvar event = this; // eslint-disable-line\n\tevent.stopped = true;\n\tEvent.prototype.stopPropagation.call(event);\n}\n\n/**\n * Checks if the given element supports the given event type.\n * @param {!Element|string} element The DOM element or element tag name to check.\n * @param {string} eventName The name of the event to check.\n * @return {boolean}\n */\nfunction supportsEvent(element, eventName) {\n\tif (customEvents[eventName]) {\n\t\treturn true;\n\t}\n\n\tif ((0, _metal.isString)(element)) {\n\t\tif (!elementsByTag_[element]) {\n\t\t\telementsByTag_[element] = document.createElement(element);\n\t\t}\n\t\telement = elementsByTag_[element];\n\t}\n\n\tvar tag = element.tagName;\n\tif (!supportCache_[tag] || !supportCache_[tag].hasOwnProperty(eventName)) {\n\t\tsupportCache_[tag] = supportCache_[tag] || {};\n\t\tsupportCache_[tag][eventName] = 'on' + eventName in element;\n\t}\n\treturn supportCache_[tag][eventName];\n}\n\n/**\n * This triggers all default matched delegated listeners of a given event type.\n * @param {!Array} defaultFns Array to collect default listeners in, instead\n * @param {!Event} event\n * @return {boolean} False if at least one of the triggered callbacks returns\n *     false, or true otherwise.\n * @private\n */\nfunction triggerDefaultDelegatedListeners_(defFns, event) {\n\tvar ret = true;\n\n\tfor (var i = 0; i < defFns.length && !event.defaultPrevented; i++) {\n\t\tevent.delegateTarget = defFns[i].element;\n\t\tret &= defFns[i].fn(event);\n\t}\n\n\treturn ret;\n}\n\n/**\n * This triggers all matched delegated listeners of a given event type when its\n * delegated target is able to interact.\n * @param {!Element} container\n * @param {!Event} event\n * @param {!Array} defaultFns Array to collect default listeners in, instead\n *     of running them.\n * @return {boolean} False if at least one of the triggered callbacks returns\n *     false, or true otherwise.\n * @private\n */\nfunction triggerDelegatedListeners_(container, event, defaultFns) {\n\tvar ret = true;\n\tvar currElement = event.target;\n\tvar limit = container.parentNode;\n\n\twhile (currElement && currElement !== limit && !event.stopped) {\n\t\tif (isAbleToInteractWith_(currElement, event.type, event)) {\n\t\t\tevent.delegateTarget = currElement;\n\t\t\tret &= triggerElementListeners_(currElement, event, defaultFns);\n\t\t\tret &= triggerSelectorListeners_(container, currElement, event, defaultFns);\n\t\t}\n\t\tcurrElement = currElement.parentNode;\n\t}\n\n\treturn ret;\n}\n\n/**\n * Converts the given argument to a DOM element. Strings are assumed to\n * be selectors, and so a matched element will be returned. If the arg\n * is already a DOM element it will be the return value.\n * @param {string|Element|Document} selectorOrElement\n * @return {Element} The converted element, or null if none was found.\n */\nfunction toElement(selectorOrElement) {\n\tif ((0, _metal.isElement)(selectorOrElement) || (0, _metal.isDocument)(selectorOrElement) || (0, _metal.isDocumentFragment)(selectorOrElement)) {\n\t\treturn selectorOrElement;\n\t} else if ((0, _metal.isString)(selectorOrElement)) {\n\t\tif (selectorOrElement[0] === '#' && selectorOrElement.indexOf(' ') === -1) {\n\t\t\treturn document.getElementById(selectorOrElement.substr(1));\n\t\t} else {\n\t\t\treturn document.querySelector(selectorOrElement);\n\t\t}\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/**\n * Adds or removes one or more classes from an element. If any of the classes\n * is present, it will be removed from the element, or added otherwise.\n * @param {!Element} element The element which classes will be toggled.\n * @param {string} classes The classes which have to added or removed from the element.\n */\nfunction toggleClasses(element, classes) {\n\tif (!(0, _metal.isObject)(element) || !(0, _metal.isString)(classes)) {\n\t\treturn;\n\t}\n\n\tif ('classList' in element) {\n\t\ttoggleClassesWithNative_(element, classes);\n\t} else {\n\t\ttoggleClassesWithoutNative_(element, classes);\n\t}\n}\n\n/**\n * Adds or removes one or more classes from an element using classList.\n * If any of the classes is present, it will be removed from the element,\n * or added otherwise.\n * @param {!Element} element The element which classes will be toggled.\n * @param {string} classes The classes which have to added or removed from the element.\n * @private\n */\nfunction toggleClassesWithNative_(element, classes) {\n\tclasses.split(' ').forEach(function (className) {\n\t\telement.classList.toggle(className);\n\t});\n}\n\n/**\n * Adds or removes one or more classes from an element without using classList.\n * If any of the classes is present, it will be removed from the element,\n * or added otherwise.\n * @param {!Element} element The element which classes will be toggled.\n * @param {string} classes The classes which have to added or removed from the element.\n * @private\n */\nfunction toggleClassesWithoutNative_(element, classes) {\n\tvar elementClassName = ' ' + element.className + ' ';\n\n\tclasses = classes.split(' ');\n\n\tfor (var i = 0; i < classes.length; i++) {\n\t\tvar className = ' ' + classes[i] + ' ';\n\t\tvar classIndex = elementClassName.indexOf(className);\n\n\t\tif (classIndex === -1) {\n\t\t\telementClassName = '' + elementClassName + classes[i] + ' ';\n\t\t} else {\n\t\t\tvar before = elementClassName.substring(0, classIndex);\n\t\t\tvar after = elementClassName.substring(classIndex + className.length);\n\t\t\telementClassName = before + ' ' + after;\n\t\t}\n\t}\n\n\telement.className = elementClassName.trim();\n}\n\n/**\n * Triggers all listeners for the given event type that are stored in the\n * specified element.\n * @param {!Element} element\n * @param {!Event} event\n * @param {!Array} defaultFns Array to collect default listeners in, instead\n *     of running them.\n * @return {boolean} False if at least one of the triggered callbacks returns\n *     false, or true otherwise.\n * @private\n */\nfunction triggerElementListeners_(element, event, defaultFns) {\n\tvar lastContainer = event[LAST_CONTAINER];\n\tif (!(0, _metal.isDef)(lastContainer) || !contains(lastContainer, element)) {\n\t\tvar listeners = _domData2.default.get(element, 'listeners', {})[event.type];\n\t\treturn triggerListeners_(listeners, event, element, defaultFns);\n\t}\n\treturn true;\n}\n\n/**\n * Triggers the specified event on the given element.\n * NOTE: This should mostly be used for testing, not on real code.\n * @param {!Element} element The node that should trigger the event.\n * @param {string} eventName The name of the event to be triggred.\n * @param {Object=} opt_eventObj An object with data that should be on the\n *   triggered event's payload.\n */\nfunction triggerEvent(element, eventName, opt_eventObj) {\n\tif (isAbleToInteractWith_(element, eventName, opt_eventObj)) {\n\t\tvar eventObj = document.createEvent('HTMLEvents');\n\t\teventObj.initEvent(eventName, true, true);\n\t\t_metal.object.mixin(eventObj, opt_eventObj);\n\t\telement.dispatchEvent(eventObj);\n\t}\n}\n\n/**\n * Triggers the given listeners array.\n * @param {Array<!function()>} listeners\n * @param {!Event} event\n * @param {!Element} element\n * @param {!Array} defaultFns Array to collect default listeners in, instead\n *     of running them.\n * @return {boolean} False if at least one of the triggered callbacks returns\n *     false, or true otherwise.\n * @private\n */\nfunction triggerListeners_(listeners, event, element, defaultFns) {\n\tvar ret = true;\n\tlisteners = listeners || [];\n\tfor (var i = 0; i < listeners.length && !event.stoppedImmediate; i++) {\n\t\tif (listeners[i].defaultListener_) {\n\t\t\tdefaultFns.push({\n\t\t\t\telement: element,\n\t\t\t\tfn: listeners[i]\n\t\t\t});\n\t\t} else {\n\t\t\tret &= listeners[i](event);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/**\n * Triggers all selector listeners for the given event.\n * @param {!Element} container\n * @param {!Element} element\n * @param {!Event} event\n * @param {!Array} defaultFns Array to collect default listeners in, instead\n *     of running them.\n * @return {boolean} False if at least one of the triggered callbacks returns\n *     false, or true otherwise.\n * @private\n */\nfunction triggerSelectorListeners_(container, element, event, defaultFns) {\n\tvar ret = true;\n\tvar data = _domData2.default.get(container, 'delegating', {});\n\tvar map = data[event.type].selectors;\n\tvar selectors = Object.keys(map);\n\tfor (var i = 0; i < selectors.length && !event.stoppedImmediate; i++) {\n\t\tif (match(element, selectors[i])) {\n\t\t\tvar listeners = map[selectors[i]];\n\t\t\tret &= triggerListeners_(listeners, event, element, defaultFns);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/domNamed.js\n// module id = 48\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nvar _domData = require('./domData');\n\nvar _domData2 = _interopRequireDefault(_domData);\n\nvar _metalEvents = require('metal-events');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * This is a special EventHandle, that is responsible for dom delegated events\n * (only the ones that receive a target element, not a selector string).\n * @extends {EventHandle}\n */\nvar DomDelegatedEventHandle = function (_EventHandle) {\n\t_inherits(DomDelegatedEventHandle, _EventHandle);\n\n\t/**\n  * The constructor for `DomDelegatedEventHandle`.\n  * @param {!Event} emitter Element the event was subscribed to.\n  * @param {string} event The name of the event that was subscribed to.\n  * @param {!Function} listener The listener subscribed to the event.\n  * @param {string=} opt_selector An optional selector used when delegating\n  *     the event.\n  * @constructor\n  */\n\tfunction DomDelegatedEventHandle(emitter, event, listener, opt_selector) {\n\t\t_classCallCheck(this, DomDelegatedEventHandle);\n\n\t\tvar _this = _possibleConstructorReturn(this, (DomDelegatedEventHandle.__proto__ || Object.getPrototypeOf(DomDelegatedEventHandle)).call(this, emitter, event, listener));\n\n\t\t_this.selector_ = opt_selector;\n\t\treturn _this;\n\t}\n\n\t/**\n  * @inheritDoc\n  */\n\n\n\t_createClass(DomDelegatedEventHandle, [{\n\t\tkey: 'removeListener',\n\t\tvalue: function removeListener() {\n\t\t\tvar delegating = _domData2.default.get(this.emitter_, 'delegating', {});\n\t\t\tvar listeners = _domData2.default.get(this.emitter_, 'listeners', {});\n\t\t\tvar selector = this.selector_;\n\t\t\tvar arr = (0, _metal.isString)(selector) ? delegating[this.event_].selectors : listeners;\n\t\t\tvar key = (0, _metal.isString)(selector) ? selector : this.event_;\n\n\t\t\t_metal.array.remove(arr[key] || [], this.listener_);\n\t\t\tif (arr[key] && arr[key].length === 0) {\n\t\t\t\tdelete arr[key];\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn DomDelegatedEventHandle;\n}(_metalEvents.EventHandle);\n\nexports.default = DomDelegatedEventHandle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/DomDelegatedEventHandle.js\n// module id = 49\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _dom = require('./dom');\n\nvar _metalEvents = require('metal-events');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * DomEventEmitterProxy utility. It extends `EventEmitterProxy` to also accept\n * dom elements as origin emitters.\n * @extends {EventEmitterProxy}\n */\nvar DomEventEmitterProxy = function (_EventEmitterProxy) {\n\t_inherits(DomEventEmitterProxy, _EventEmitterProxy);\n\n\tfunction DomEventEmitterProxy() {\n\t\t_classCallCheck(this, DomEventEmitterProxy);\n\n\t\treturn _possibleConstructorReturn(this, (DomEventEmitterProxy.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy)).apply(this, arguments));\n\t}\n\n\t_createClass(DomEventEmitterProxy, [{\n\t\tkey: 'addListener_',\n\n\t\t/**\n   * Adds the given listener for the given event.\n   * @param {string} event\n   * @param {!function()} listener\n   * @return {!EventHandle} The listened event's handle.\n   * @protected\n   * @override\n   */\n\t\tvalue: function addListener_(event, listener) {\n\t\t\tif (this.originEmitter_.addEventListener) {\n\t\t\t\tif (this.isDelegateEvent_(event)) {\n\t\t\t\t\tvar index = event.indexOf(':', 9);\n\t\t\t\t\tvar eventName = event.substring(9, index);\n\t\t\t\t\tvar selector = event.substring(index + 1);\n\t\t\t\t\treturn (0, _dom.delegate)(this.originEmitter_, eventName, selector, listener);\n\t\t\t\t} else {\n\t\t\t\t\treturn (0, _dom.on)(this.originEmitter_, event, listener);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'addListener_', this).call(this, event, listener);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Checks if the given event is of the delegate type.\n   * @param {string} event\n   * @return {boolean}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'isDelegateEvent_',\n\t\tvalue: function isDelegateEvent_(event) {\n\t\t\treturn event.substr(0, 9) === 'delegate:';\n\t\t}\n\n\t\t/**\n   * Checks if the given event is supported by the origin element.\n   * @param {string} event\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'isSupportedDomEvent_',\n\t\tvalue: function isSupportedDomEvent_(event) {\n\t\t\tif (!this.originEmitter_ || !this.originEmitter_.addEventListener) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this.isDelegateEvent_(event) && event.indexOf(':', 9) !== -1 || (0, _dom.supportsEvent)(this.originEmitter_, event);\n\t\t}\n\n\t\t/**\n   * Checks if the given event should be proxied.\n   * @param {string} event\n   * @return {boolean}\n   * @protected\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'shouldProxyEvent_',\n\t\tvalue: function shouldProxyEvent_(event) {\n\t\t\treturn _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'shouldProxyEvent_', this).call(this, event) && this.isSupportedDomEvent_(event);\n\t\t}\n\t}]);\n\n\treturn DomEventEmitterProxy;\n}(_metalEvents.EventEmitterProxy);\n\nexports.default = DomEventEmitterProxy;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/DomEventEmitterProxy.js\n// module id = 50\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nvar _dom = require('./dom');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Utility functions for running javascript code in the global scope.\n */\nvar globalEval = function () {\n\tfunction globalEval() {\n\t\t_classCallCheck(this, globalEval);\n\t}\n\n\t_createClass(globalEval, null, [{\n\t\tkey: 'run',\n\n\t\t/**\n   * Evaluates the given string in the global scope.\n   * @param {string} text\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   * @return {Element} script\n   */\n\t\tvalue: function run(text, opt_appendFn) {\n\t\t\tvar script = document.createElement('script');\n\t\t\tscript.text = text;\n\t\t\tif (opt_appendFn) {\n\t\t\t\topt_appendFn(script);\n\t\t\t} else {\n\t\t\t\tdocument.head.appendChild(script);\n\t\t\t}\n\t\t\t(0, _dom.exitDocument)(script);\n\t\t\treturn script;\n\t\t}\n\n\t\t/**\n   * Evaluates the given javascript file in the global scope.\n   * @param {string} src The file's path.\n   * @param {function()=} opt_callback Optional function to be called\n   *   when the script has been run.\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   * @return {Element} script\n   */\n\n\t}, {\n\t\tkey: 'runFile',\n\t\tvalue: function runFile(src, opt_callback, opt_appendFn) {\n\t\t\tvar script = document.createElement('script');\n\t\t\tscript.src = src;\n\n\t\t\tvar callback = function callback() {\n\t\t\t\t(0, _dom.exitDocument)(script);\n\t\t\t\topt_callback && opt_callback();\n\t\t\t};\n\t\t\t(0, _dom.once)(script, 'load', callback);\n\t\t\t(0, _dom.once)(script, 'error', callback);\n\n\t\t\tif (opt_appendFn) {\n\t\t\t\topt_appendFn(script);\n\t\t\t} else {\n\t\t\t\tdocument.head.appendChild(script);\n\t\t\t}\n\n\t\t\treturn script;\n\t\t}\n\n\t\t/**\n   * Evaluates the code referenced by the given script element.\n   * @param {!Element} script\n   * @param {function()=} opt_callback Optional function to be called\n   *   when the script has been run.\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   * @return {Element} script\n   */\n\n\t}, {\n\t\tkey: 'runScript',\n\t\tvalue: function runScript(script, opt_callback, opt_appendFn) {\n\t\t\tvar callback = function callback() {\n\t\t\t\topt_callback && opt_callback();\n\t\t\t};\n\t\t\tif (script.type && script.type !== 'text/javascript') {\n\t\t\t\t_metal.async.nextTick(callback);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t(0, _dom.exitDocument)(script);\n\t\t\tif (script.src) {\n\t\t\t\treturn globalEval.runFile(script.src, opt_callback, opt_appendFn);\n\t\t\t} else {\n\t\t\t\t_metal.async.nextTick(callback);\n\t\t\t\treturn globalEval.run(script.text, opt_appendFn);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Evaluates any script tags present in the given element.\n   * @param {!Element} element\n   * @param {function()=} opt_callback Optional function to be called\n   *   when the script has been run.\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   */\n\n\t}, {\n\t\tkey: 'runScriptsInElement',\n\t\tvalue: function runScriptsInElement(element, opt_callback, opt_appendFn) {\n\t\t\tvar scripts = element.querySelectorAll('script');\n\t\t\tif (scripts.length) {\n\t\t\t\tglobalEval.runScriptsInOrder(scripts, 0, opt_callback, opt_appendFn);\n\t\t\t} else if (opt_callback) {\n\t\t\t\t_metal.async.nextTick(opt_callback);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Runs the given scripts elements in the order that they appear.\n   * @param {!NodeList} scripts\n   * @param {number} index\n   * @param {function()=} opt_callback Optional function to be called\n   *   when the script has been run.\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   */\n\n\t}, {\n\t\tkey: 'runScriptsInOrder',\n\t\tvalue: function runScriptsInOrder(scripts, index, opt_callback, opt_appendFn) {\n\t\t\tglobalEval.runScript(scripts.item(index), function () {\n\t\t\t\tif (index < scripts.length - 1) {\n\t\t\t\t\tglobalEval.runScriptsInOrder(scripts, index + 1, opt_callback, opt_appendFn);\n\t\t\t\t} else if (opt_callback) {\n\t\t\t\t\t_metal.async.nextTick(opt_callback);\n\t\t\t\t}\n\t\t\t}, opt_appendFn);\n\t\t}\n\t}]);\n\n\treturn globalEval;\n}();\n\nexports.default = globalEval;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/globalEval.js\n// module id = 51\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nvar _dom = require('./dom');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Utility functions for running styles.\n */\nvar globalEvalStyles = function () {\n\tfunction globalEvalStyles() {\n\t\t_classCallCheck(this, globalEvalStyles);\n\t}\n\n\t_createClass(globalEvalStyles, null, [{\n\t\tkey: 'run',\n\n\t\t/**\n   * Evaluates the given style.\n   * @param {string} text\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   * @return {Element} style\n   */\n\t\tvalue: function run(text, opt_appendFn) {\n\t\t\tvar style = document.createElement('style');\n\t\t\tstyle.innerHTML = text;\n\t\t\tif (opt_appendFn) {\n\t\t\t\topt_appendFn(style);\n\t\t\t} else {\n\t\t\t\tdocument.head.appendChild(style);\n\t\t\t}\n\t\t\treturn style;\n\t\t}\n\n\t\t/**\n   * Evaluates the given style file.\n   * @param {string} href The file's path.\n   * @param {function()=} opt_callback Optional function to be called\n   *   when the styles has been run.\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   * @return {Element} style\n   */\n\n\t}, {\n\t\tkey: 'runFile',\n\t\tvalue: function runFile(href, opt_callback, opt_appendFn) {\n\t\t\tvar link = document.createElement('link');\n\t\t\tlink.rel = 'stylesheet';\n\t\t\tlink.href = href;\n\t\t\tglobalEvalStyles.runStyle(link, opt_callback, opt_appendFn);\n\t\t\treturn link;\n\t\t}\n\n\t\t/**\n   * Evaluates the code referenced by the given style/link element.\n   * @param {!Element} style\n   * @param {function()=} opt_callback Optional function to be called\n   *   when the script has been run.\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   *  @return {Element} style\n   */\n\n\t}, {\n\t\tkey: 'runStyle',\n\t\tvalue: function runStyle(style, opt_callback, opt_appendFn) {\n\t\t\tvar callback = function callback() {\n\t\t\t\topt_callback && opt_callback();\n\t\t\t};\n\t\t\tif (style.rel && style.rel !== 'stylesheet') {\n\t\t\t\t_metal.async.nextTick(callback);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (style.tagName === 'STYLE') {\n\t\t\t\t_metal.async.nextTick(callback);\n\t\t\t} else {\n\t\t\t\t(0, _dom.once)(style, 'load', callback);\n\t\t\t\t(0, _dom.once)(style, 'error', callback);\n\t\t\t}\n\n\t\t\tif (opt_appendFn) {\n\t\t\t\topt_appendFn(style);\n\t\t\t} else {\n\t\t\t\tdocument.head.appendChild(style);\n\t\t\t}\n\n\t\t\treturn style;\n\t\t}\n\n\t\t/**\n   * Evaluates any style present in the given element.\n   * @param {!Element} element\n   * @param {function()=} opt_callback Optional function to be called when the\n   *   style has been run.\n   * @param {function()=} opt_appendFn Optional function to append the node\n   *   into document.\n   */\n\n\t}, {\n\t\tkey: 'runStylesInElement',\n\t\tvalue: function runStylesInElement(element, opt_callback, opt_appendFn) {\n\t\t\tvar styles = element.querySelectorAll('style,link');\n\t\t\tif (styles.length === 0 && opt_callback) {\n\t\t\t\t_metal.async.nextTick(opt_callback);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar loadCount = 0;\n\t\t\tvar callback = function callback() {\n\t\t\t\tif (opt_callback && ++loadCount === styles.length) {\n\t\t\t\t\t_metal.async.nextTick(opt_callback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\t\tglobalEvalStyles.runStyle(styles[i], callback, opt_appendFn);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn globalEvalStyles;\n}();\n\nexports.default = globalEvalStyles;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/globalEvalStyles.js\n// module id = 52\n// module chunks = 0","'use strict';\n\nvar _dom = require('./dom');\n\nvar _features = require('./features');\n\nvar _features2 = _interopRequireDefault(_features);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar mouseEventMap = {\n\tmouseenter: 'mouseover',\n\tmouseleave: 'mouseout',\n\tpointerenter: 'pointerover',\n\tpointerleave: 'pointerout'\n};\nObject.keys(mouseEventMap).forEach(function (eventName) {\n\t(0, _dom.registerCustomEvent)(eventName, {\n\t\tdelegate: true,\n\t\thandler: function handler(callback, event) {\n\t\t\tvar related = event.relatedTarget;\n\t\t\tvar target = event.delegateTarget;\n\t\t\tif (!related || related !== target && !(0, _dom.contains)(target, related)) {\n\t\t\t\tevent.customType = eventName;\n\t\t\t\treturn callback(event);\n\t\t\t}\n\t\t},\n\t\toriginalEvent: mouseEventMap[eventName]\n\t});\n});\n\nvar animationEventMap = {\n\tanimation: 'animationend',\n\ttransition: 'transitionend'\n};\nObject.keys(animationEventMap).forEach(function (eventType) {\n\tvar eventName = animationEventMap[eventType];\n\t(0, _dom.registerCustomEvent)(eventName, {\n\t\tevent: true,\n\t\tdelegate: true,\n\t\thandler: function handler(callback, event) {\n\t\t\tevent.customType = eventName;\n\t\t\treturn callback(event);\n\t\t},\n\t\toriginalEvent: _features2.default.checkAnimationEventName()[eventType]\n\t});\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-dom/lib/events.js\n// module id = 53\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyAttribute = applyAttribute;\nexports.convertListenerNamesToFns = convertListenerNamesToFns;\n\nvar _metal = require('metal');\n\nvar _metalDom = require('metal-dom');\n\nvar _metalComponent = require('metal-component');\n\nvar _incrementalDomAop = require('../incremental-dom-aop');\n\nvar HANDLE_SUFFIX = '__handle__';\nvar LISTENER_REGEX = /^(?:on([A-Z].+))|(?:data-on(.+))$/;\n\n/**\n * Applies an attribute to a specified element owned by the given component.\n * @param {!Component} component\n * @param {!Element} element\n * @param {string} name\n * @param {*} value\n */\nfunction applyAttribute(component, element, name, value) {\n  var eventName = getEventFromListenerAttr_(name);\n  if (eventName) {\n    attachEvent_(component, element, name, eventName, value);\n    return;\n  }\n\n  value = fixCheckedAttr_(name, value);\n  setValueAttrAsProperty_(element, name, value);\n\n  if ((0, _metal.isBoolean)(value)) {\n    setBooleanAttr_(element, name, value);\n  } else {\n    (0, _incrementalDomAop.getOriginalFn)('attributes')(element, name, value);\n  }\n}\n\n/**\n * Listens to the specified event, attached via incremental dom calls.\n * @param {!Component} component\n * @param {!Element} element\n * @param {string} attr\n * @param {string} eventName\n * @param {function()} fn\n * @private\n */\nfunction attachEvent_(component, element, attr, eventName, fn) {\n  if ((0, _metal.isServerSide)()) {\n    return;\n  }\n  var handleKey = eventName + HANDLE_SUFFIX;\n  if (element[handleKey]) {\n    element[handleKey].removeListener();\n    element[handleKey] = null;\n  }\n  if (fn) {\n    element[attr] = fn;\n    element[handleKey] = (0, _metalDom.delegate)(document, eventName, element, fn);\n  }\n}\n\n/**\n * Converts all event listener attributes given as function names to actual\n * function references. It's important to do this before calling the real\n * incremental dom `elementOpen` function, otherwise if a component passes\n * the same function name that an element was already using for another\n * component, that event won't be reattached as incremental dom will think that\n * the value hasn't changed. Passing the function references as the value will\n * guarantee that different functions will cause events to be reattached,\n * regardless of their original names.\n * @param {!Component} component\n * @param {!Object} config\n */\nfunction convertListenerNamesToFns(component, config) {\n  var keys = Object.keys(config);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    config[key] = convertListenerNameToFn_(component, key, config[key]);\n  }\n}\n\n/**\n * Converts the given attribute's value to a function reference, if it's\n * currently a listener name. It also register the listener name for\n * further usage.\n * @param {!Component} component\n * @param {string} name\n * @param {*} value\n * @return {*}\n * @private\n */\nfunction convertListenerNameToFn_(component, name, value) {\n  if ((0, _metal.isString)(value)) {\n    var eventName = getEventFromListenerAttr_(name);\n    if (eventName) {\n      var fn = (0, _metalComponent.getComponentFn)(component, value);\n      if (fn) {\n        return fn;\n      }\n    }\n  }\n  return value;\n}\n\n/**\n * Changes the value of the `checked` attribute to be a boolean.\n * NOTE: This is a temporary fix to account for incremental dom setting\n * \"checked\" as an attribute only, which can cause bugs since that won't\n * necessarily check/uncheck the element it's set on. See\n * https://github.com/google/incremental-dom/issues/198 for more details.\n * @param {string} name\n * @param {*} value\n * @return {*}\n * @private\n */\nfunction fixCheckedAttr_(name, value) {\n  if (name === 'checked') {\n    value = (0, _metal.isDefAndNotNull)(value) && value !== false;\n  }\n  return value;\n}\n\n/**\n * Returns the event name if the given attribute is a listener (matching the\n * `LISTENER_REGEX` regex), or null if it isn't.\n * @param {string} attr\n * @return {?string}\n * @private\n */\nfunction getEventFromListenerAttr_(attr) {\n  var matches = LISTENER_REGEX.exec(attr);\n  var eventName = matches ? matches[1] ? matches[1] : matches[2] : null;\n  return eventName ? eventName.toLowerCase() : null;\n}\n\n/**\n * Sets boolean attributes manually. This is done because incremental dom sets\n * boolean values as string data attributes by default, which is counter\n * intuitive. This changes the behavior to use the actual boolean value.\n * @param {!Element} element\n * @param {string} name\n * @param {*} value\n * @private\n */\nfunction setBooleanAttr_(element, name, value) {\n  if ((0, _metal.isServerSide)()) {\n    return;\n  }\n  element[name] = value;\n  if (value) {\n    element.setAttribute(name, '');\n  } else {\n    element.removeAttribute(name);\n  }\n}\n\n/**\n * Sets the value of the `value` attribute directly in the element.\n * NOTE: This is a temporary fix to account for incremental dom setting \"value\"\n * as an attribute only, which can cause bugs since that won't necessarily\n * update the input's content it's set on. See\n * https://github.com/google/incremental-dom/issues/239 for more details. We\n * only do this if the new value is different though, as otherwise the browser\n * will automatically move the typing cursor to the end of the field.\n * @param {!Element} element\n * @param {string} name\n * @param {*} value\n * @private\n */\nfunction setValueAttrAsProperty_(element, name, value) {\n  if ((0, _metal.isServerSide)()) {\n    return;\n  }\n  if (name === 'value' && element.value !== value) {\n    element[name] = value;\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/render/attributes.js\n// module id = 54\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _events = require('./events/events');\n\nvar _metal = require('metal');\n\nvar _sync = require('./sync/sync');\n\nvar _metalDom = require('metal-dom');\n\nvar _ComponentDataManager = require('./ComponentDataManager');\n\nvar _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);\n\nvar _ComponentRenderer = require('./ComponentRenderer');\n\nvar _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);\n\nvar _metalEvents = require('metal-events');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Component collects common behaviors to be followed by UI components, such\n * as Lifecycle, CSS classes management, events encapsulation and support for\n * different types of rendering.\n * Rendering logic can be done by either:\n *     - Listening to the `render` event inside the `created` lifecycle function\n *       and adding the rendering logic to the listener.\n *     - Using an existing implementation of `ComponentRenderer` like `Soy`,\n *       and following its patterns.\n *     - Building your own implementation of a `ComponentRenderer`.\n * Specifying the renderer that will be used can be done by setting the RENDERER\n * static variable to the renderer's constructor function.\n *\n * Example:\n *\n * <code>\n * class CustomComponent extends Component {\n *   created() {\n *   }\n *\n *   rendered() {\n *   }\n *\n *   attached() {\n *   }\n *\n *   detached() {\n *   }\n *\n *   disposed() {\n *   }\n * }\n *\n * CustomComponent.RENDERER = MyRenderer;\n *\n * CustomComponent.STATE = {\n *   title: { value: 'Title' },\n *   fontSize: { value: '10px' }\n * };\n * </code>\n *\n * @extends {State}\n */\nvar Component = function (_EventEmitter) {\n\t_inherits(Component, _EventEmitter);\n\n\t/**\n  * Constructor function for `Component`.\n  * @param {Object=} opt_config An object with the initial values for this\n  *     component's state.\n  * @param {boolean|string|Element=} opt_parentElement The element where the\n  *     component should be rendered. Can be given as a selector or an element.\n  *     If `false` is passed, the component won't be rendered automatically\n  *     after created.\n  * @constructor\n  */\n\tfunction Component(opt_config, opt_parentElement) {\n\t\t_classCallCheck(this, Component);\n\n\t\t/**\n   * Instance of `DomEventEmitterProxy` which proxies events from the component's\n   * element to the component itself.\n   * @type {!DomEventEmitterProxy}\n   * @protected\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this));\n\n\t\t_this.elementEventProxy_ = new _metalDom.DomEventEmitterProxy(null, _this, proxyBlackList_);\n\n\t\t/**\n   * The `EventHandler` instance for events attached from the `events` state key.\n   * @type {EventHandler}\n   * @protected\n   */\n\t\t_this.eventsStateKeyHandler_ = null;\n\n\t\t/**\n   * Whether the element is in document.\n   * @type {boolean}\n   */\n\t\t_this.inDocument = false;\n\n\t\t/**\n   * The initial config option passed to this constructor.\n   * @type {!Object}\n   * @protected\n   */\n\t\t_this.initialConfig_ = opt_config || {};\n\n\t\t/**\n   * Whether the element was rendered.\n   * @type {boolean}\n   */\n\t\t_this.wasRendered = false;\n\n\t\t/**\n   * The component's element will be appended to the element this variable is\n   * set to, unless the user specifies another parent when calling `render` or\n   * `attach`.\n   * @type {!Element}\n   */\n\t\t_this.DEFAULT_ELEMENT_PARENT = document.body;\n\n\t\t_this.setShouldUseFacade(true);\n\t\t_this.element = _this.initialConfig_.element;\n\n\t\t_this.setUpRenderer_();\n\t\t_this.setUpDataManager_();\n\t\t_this.setUpSyncUpdates_();\n\n\t\t_this.on('stateChanged', _this.handleComponentStateChanged_);\n\t\t_this.on('eventsChanged', _this.onEventsChanged_);\n\t\t_this.addListenersFromObj_(_this.dataManager_.get(_this, 'events'));\n\n\t\t_this.created();\n\t\t_this.componentCreated_ = true;\n\t\tif (opt_parentElement !== false) {\n\t\t\t_this.renderComponent(opt_parentElement);\n\t\t}\n\t\treturn _this;\n\t}\n\n\t/**\n  * Getter logic for the element property.\n  * @return {Element}\n  */\n\n\n\t_createClass(Component, [{\n\t\tkey: 'addListenersFromObj_',\n\n\n\t\t/**\n   * Adds the listeners specified in the given object.\n   * @param {!Object} obj\n   * @protected\n   */\n\t\tvalue: function addListenersFromObj_(obj) {\n\t\t\tvar _eventsStateKeyHandle;\n\n\t\t\tif (!this.eventsStateKeyHandler_) {\n\t\t\t\tthis.eventsStateKeyHandler_ = new _metalEvents.EventHandler();\n\t\t\t}\n\t\t\tvar handles = (0, _events.addListenersFromObj)(this, obj);\n\t\t\t(_eventsStateKeyHandle = this.eventsStateKeyHandler_).add.apply(_eventsStateKeyHandle, _toConsumableArray(handles));\n\t\t}\n\n\t\t/**\n   * Invokes the attached Lifecycle. When attached, the component element is\n   * appended to the DOM and any other action to be performed must be\n   * implemented in this method, such as, binding DOM events. A component can\n   * be re-attached multiple times.\n   * @param {(string|Element)=} opt_parentElement Optional parent element\n   *     to render the component.\n   * @param {(string|Element)=} opt_siblingElement Optional sibling element\n   *     to render the component before it. Relevant when the component needs\n   *     to be rendered before an existing element in the DOM.\n   * @protected\n   * @chainable\n   */\n\n\t}, {\n\t\tkey: 'attach',\n\t\tvalue: function attach(opt_parentElement, opt_siblingElement) {\n\t\t\tif (!this.inDocument) {\n\t\t\t\tthis.attachElement(opt_parentElement, opt_siblingElement);\n\t\t\t\tthis.inDocument = true;\n\t\t\t\tthis.attachData_ = {\n\t\t\t\t\tparent: opt_parentElement,\n\t\t\t\t\tsibling: opt_siblingElement\n\t\t\t\t};\n\t\t\t\tthis.emit('attached', this.attachData_);\n\t\t\t\tthis.attached();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Lifecycle. When attached, the component element is appended to the DOM\n   * and any other action to be performed must be implemented in this method,\n   * such as, binding DOM events. A component can be re-attached multiple\n   * times, therefore the undo behavior for any action performed in this phase\n   * must be implemented on the detach phase.\n   */\n\n\t}, {\n\t\tkey: 'attached',\n\t\tvalue: function attached() {}\n\n\t\t/**\n   * Attaches the component element into the DOM.\n   * @param {(string|Element)=} opt_parentElement Optional parent element\n   *     to render the component.\n   * @param {(string|Element)=} opt_siblingElement Optional sibling element\n   *     to render the component before it. Relevant when the component needs\n   *     to be rendered before an existing element in the DOM, e.g.\n   *     `component.attach(null, existingElement)`.\n   */\n\n\t}, {\n\t\tkey: 'attachElement',\n\t\tvalue: function attachElement(opt_parentElement, opt_siblingElement) {\n\t\t\tvar element = this.element;\n\t\t\tif (element && (opt_siblingElement || !element.parentNode)) {\n\t\t\t\tvar parent = (0, _metalDom.toElement)(opt_parentElement) || this.DEFAULT_ELEMENT_PARENT;\n\t\t\t\tparent.insertBefore(element, (0, _metalDom.toElement)(opt_siblingElement));\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Lifecycle. This is called when the component has just been created, before\n   * it's rendered.\n   */\n\n\t}, {\n\t\tkey: 'created',\n\t\tvalue: function created() {}\n\n\t\t/**\n   * Listens to a delegate event on the component's element.\n   * @param {string} eventName The name of the event to listen to.\n   * @param {string} selector The selector that matches the child elements that\n   *   the event should be triggered for.\n   * @param {!function(!Object)} callback Function to be called when the event is\n   *   triggered. It will receive the normalized event object.\n   * @return {!EventHandle} Can be used to remove the listener.\n   */\n\n\t}, {\n\t\tkey: 'delegate',\n\t\tvalue: function delegate(eventName, selector, callback) {\n\t\t\treturn this.on('delegate:' + eventName + ':' + selector, callback);\n\t\t}\n\n\t\t/**\n   * Invokes the detached Lifecycle. When detached, the component element is\n   * removed from the DOM and any other action to be performed must be\n   * implemented in this method, such as, unbinding DOM events. A component\n   * can be detached multiple times.\n   * @chainable\n   */\n\n\t}, {\n\t\tkey: 'detach',\n\t\tvalue: function detach() {\n\t\t\tif (this.inDocument) {\n\t\t\t\tif (this.element && this.element.parentNode) {\n\t\t\t\t\tthis.element.parentNode.removeChild(this.element);\n\t\t\t\t}\n\t\t\t\tthis.inDocument = false;\n\t\t\t\tthis.detached();\n\t\t\t}\n\t\t\tthis.emit('detached');\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Lifecycle. When detached, the component element is removed from the DOM\n   * and any other action to be performed must be implemented in this method,\n   * such as, unbinding DOM events. A component can be detached multiple\n   * times, therefore the undo behavior for any action performed in this phase\n   * must be implemented on the attach phase.\n   */\n\n\t}, {\n\t\tkey: 'detached',\n\t\tvalue: function detached() {}\n\n\t\t/**\n   * Lifecycle. Called when the component is disposed. Should be overridden by\n   * sub classes to dispose of any internal data or events.\n   */\n\n\t}, {\n\t\tkey: 'disposed',\n\t\tvalue: function disposed() {}\n\n\t\t/**\n   * @inheritDoc\n   */\n\n\t}, {\n\t\tkey: 'disposeInternal',\n\t\tvalue: function disposeInternal() {\n\t\t\tthis.detach();\n\t\t\tthis.disposed();\n\n\t\t\tthis.elementEventProxy_.dispose();\n\t\t\tthis.elementEventProxy_ = null;\n\n\t\t\tthis.dataManager_.dispose(this);\n\t\t\tthis.dataManager_ = null;\n\n\t\t\tthis.renderer_.dispose(this);\n\t\t\tthis.renderer_ = null;\n\n\t\t\t_get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'disposeInternal', this).call(this);\n\t\t}\n\n\t\t/**\n   * Gets data about where this component was attached at.\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getAttachData',\n\t\tvalue: function getAttachData() {\n\t\t\treturn this.attachData_;\n\t\t}\n\n\t\t/**\n   * Gets the `ComponentDataManager` being used.\n   * @return {!ComponentDataManager}\n   */\n\n\t}, {\n\t\tkey: 'getDataManager',\n\t\tvalue: function getDataManager() {\n\t\t\treturn this.dataManager_;\n\t\t}\n\n\t\t/**\n   * Gets the configuration object that was passed to this component's constructor.\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getInitialConfig',\n\t\tvalue: function getInitialConfig() {\n\t\t\treturn this.initialConfig_;\n\t\t}\n\n\t\t/**\n   * Gets state data for this component.\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getState',\n\t\tvalue: function getState() {\n\t\t\treturn this.dataManager_.getState(this);\n\t\t}\n\n\t\t/**\n   * Gets the keys for the state data.\n   * @return {!Array<string>}\n   */\n\n\t}, {\n\t\tkey: 'getStateKeys',\n\t\tvalue: function getStateKeys() {\n\t\t\treturn this.dataManager_.getStateKeys(this);\n\t\t}\n\n\t\t/**\n   * Gets the `ComponentRenderer` instance being used.\n   * @return {!ComponentRenderer}\n   */\n\n\t}, {\n\t\tkey: 'getRenderer',\n\t\tvalue: function getRenderer() {\n\t\t\treturn this.renderer_;\n\t\t}\n\n\t\t/**\n   * Handles a change in the component's element.\n   * @param {Element} prevVal\n   * @param {Element} newVal\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'handleComponentElementChanged_',\n\t\tvalue: function handleComponentElementChanged_(prevVal, newVal) {\n\t\t\tthis.elementEventProxy_.setOriginEmitter(newVal);\n\t\t\tif (this.componentCreated_) {\n\t\t\t\tthis.emit('elementChanged', {\n\t\t\t\t\tprevVal: prevVal,\n\t\t\t\t\tnewVal: newVal\n\t\t\t\t});\n\t\t\t\tif (newVal && this.wasRendered) {\n\t\t\t\t\tthis.syncVisible(this.dataManager_.get(this, 'visible'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Handles state batch changes. Calls any existing `sync` functions that\n   * match the changed state keys.\n   * @param {Event} event\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'handleComponentStateChanged_',\n\t\tvalue: function handleComponentStateChanged_(event) {\n\t\t\tif (!this.hasSyncUpdates()) {\n\t\t\t\tthis.updateRenderer_(event);\n\t\t\t}\n\t\t\t(0, _sync.syncState)(this, event.changes);\n\t\t\tthis.emit('stateSynced', event);\n\t\t}\n\n\t\t/**\n   * Handles a `stateKeyChanged` event. This is only called for components that\n   * have requested updates to happen synchronously.\n   * @param {!{key: string, newVal: *, prevVal: *}} data\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'handleComponentStateKeyChanged_',\n\t\tvalue: function handleComponentStateKeyChanged_(data) {\n\t\t\tthis.updateRenderer_({\n\t\t\t\tchanges: _defineProperty({}, data.key, data)\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Checks if this component has sync updates enabled.\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'hasSyncUpdates',\n\t\tvalue: function hasSyncUpdates() {\n\t\t\treturn this.syncUpdates_;\n\t\t}\n\n\t\t/**\n   * Informs that the component that the rendered has finished rendering it. The\n   * renderer is the one responsible for calling this when appropriate. This\n   * will emit events and run the appropriate lifecycle for the first render.\n   */\n\n\t}, {\n\t\tkey: 'informRendered',\n\t\tvalue: function informRendered() {\n\t\t\tvar firstRender = !this.hasRendererRendered_;\n\t\t\tthis.hasRendererRendered_ = true;\n\t\t\tthis.rendered(firstRender);\n\t\t\tthis.emit('rendered', firstRender);\n\t\t}\n\n\t\t/**\n   * Checks if the given function is a component constructor.\n   * @param {!function()} fn Any function\n   * @return {boolean}\n   */\n\n\t}, {\n\t\tkey: 'mergeElementClasses_',\n\n\n\t\t/**\n   * Merges two values for the ELEMENT_CLASSES property into a single one.\n   * @param {string} class1\n   * @param {string} class2\n   * @return {string} The merged value.\n   * @protected\n   */\n\t\tvalue: function mergeElementClasses_(class1, class2) {\n\t\t\treturn class1 ? class1 + ' ' + (class2 || '') : class2;\n\t\t}\n\n\t\t/**\n   * Fired when the `events` state value is changed.\n   * @param {!Object} event\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'onEventsChanged_',\n\t\tvalue: function onEventsChanged_(event) {\n\t\t\tthis.eventsStateKeyHandler_.removeAllListeners();\n\t\t\tthis.addListenersFromObj_(event.newVal);\n\t\t}\n\n\t\t/**\n   * Creates and renders a component for the given constructor function. This\n   * will always make sure that the constructor runs without rendering the\n   * component, having the `render` step happen only after it has finished.\n   * @param {!function()} Ctor The component's constructor function.\n   * @param {Object|Element=} opt_configOrElement Optional config data or parent\n   *     for the component.\n   * @param {Element=} opt_element Optional parent for the component.\n   * @return {!Component} The rendered component's instance.\n   */\n\n\t}, {\n\t\tkey: 'renderComponent',\n\n\n\t\t/**\n   * Renders the component into the DOM via its `ComponentRenderer`. Stores the\n   * given parent element to be used when the renderer is done (`informRendered`).\n   * @param {(string|Element|boolean)=} opt_parentElement Optional parent element\n   *     to render the component. If set to `false`, the element won't be\n   *     attached to any element after rendering. In this case, `attach` should\n   *     be called manually later to actually attach it to the dom.\n   */\n\t\tvalue: function renderComponent(opt_parentElement) {\n\t\t\tif (!this.hasRendererRendered_) {\n\t\t\t\tif (window.__METAL_DEV_TOOLS_HOOK__) {\n\t\t\t\t\twindow.__METAL_DEV_TOOLS_HOOK__(this);\n\t\t\t\t}\n\t\t\t\tthis.getRenderer().render(this);\n\t\t\t}\n\t\t\tthis.emit('render');\n\t\t\t(0, _sync.syncState)(this);\n\t\t\tthis.attach(opt_parentElement);\n\t\t\tthis.wasRendered = true;\n\t\t}\n\n\t\t/**\n   * Setter logic for the element property.\n   * @param {?string|Element} val\n   */\n\n\t}, {\n\t\tkey: 'setState',\n\n\n\t\t/**\n   * Sets the value of all the specified state keys.\n   * @param {!Object.<string,*>} values A map of state keys to the values they\n   *   should be set to.\n   * @param {function()=} opt_callback An optional function that will be run\n   *   after the next batched update is triggered.\n   */\n\t\tvalue: function setState(state, opt_callback) {\n\t\t\tthis.dataManager_.setState(this, state, opt_callback);\n\t\t}\n\n\t\t/**\n   * Setter for the `elementClasses` data property. Appends given value with\n   * the one specified in `ELEMENT_CLASSES`.\n   * @param {string} val\n   * @return {string}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'setterElementClassesFn_',\n\t\tvalue: function setterElementClassesFn_(val) {\n\t\t\tvar elementClasses = (0, _metal.getStaticProperty)(this.constructor, 'ELEMENT_CLASSES', this.mergeElementClasses_);\n\t\t\tif (elementClasses) {\n\t\t\t\tval += ' ' + elementClasses;\n\t\t\t}\n\t\t\treturn val.trim();\n\t\t}\n\n\t\t/**\n   * Sets up the component's data manager.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'setUpDataManager_',\n\t\tvalue: function setUpDataManager_() {\n\t\t\tthis.dataManager_ = (0, _metal.getStaticProperty)(this.constructor, 'DATA_MANAGER');\n\t\t\tthis.dataManager_.setUp(this, _metal.object.mixin({}, this.renderer_.getExtraDataConfig(this), Component.DATA));\n\t\t}\n\n\t\t/**\n   * Sets up the component's renderer.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'setUpRenderer_',\n\t\tvalue: function setUpRenderer_() {\n\t\t\tthis.renderer_ = (0, _metal.getStaticProperty)(this.constructor, 'RENDERER');\n\t\t\tthis.renderer_.setUp(this);\n\t\t}\n\n\t\t/**\n   * Sets up the component to use sync updates when `SYNC_UPDATES` is `true`.\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'setUpSyncUpdates_',\n\t\tvalue: function setUpSyncUpdates_() {\n\t\t\tthis.syncUpdates_ = (0, _metal.getStaticProperty)(this.constructor, 'SYNC_UPDATES');\n\t\t\tif (this.hasSyncUpdates()) {\n\t\t\t\tthis.on('stateKeyChanged', this.handleComponentStateKeyChanged_.bind(this));\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Skips renderer updates until `stopSkipUpdates` is called.\n   */\n\n\t}, {\n\t\tkey: 'startSkipUpdates',\n\t\tvalue: function startSkipUpdates() {\n\t\t\tthis.skipUpdates_ = true;\n\t\t}\n\n\t\t/**\n   * Stops skipping renderer updates.\n   */\n\n\t}, {\n\t\tkey: 'stopSkipUpdates',\n\t\tvalue: function stopSkipUpdates() {\n\t\t\tthis.skipUpdates_ = false;\n\t\t}\n\n\t\t/**\n   * State synchronization logic for `visible` state key.\n   * Updates the element's display value according to its visibility.\n   * @param {boolean} newVal\n   */\n\n\t}, {\n\t\tkey: 'syncVisible',\n\t\tvalue: function syncVisible(newVal) {\n\t\t\tif (this.element) {\n\t\t\t\tthis.element.style.display = newVal ? '' : 'none';\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Lifecycle. Called whenever the component has just been rendered.\n   * @param {boolean} firstRender Flag indicating if this was the component's\n   *     first render.\n   */\n\n\t}, {\n\t\tkey: 'rendered',\n\t\tvalue: function rendered() {}\n\n\t\t/**\n   * Calls \"update\" on the renderer, passing it the changed data.\n   * @param {!{changes: !Object}} data\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'updateRenderer_',\n\t\tvalue: function updateRenderer_(data) {\n\t\t\tif (!this.skipUpdates_ && this.hasRendererRendered_) {\n\t\t\t\tthis.getRenderer().update(this, data);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Validator logic for the `events` state key.\n   * @param {Object} val\n   * @return {boolean}\n   * @protected\n   */\n\n\t}, {\n\t\tkey: 'validatorEventsFn_',\n\t\tvalue: function validatorEventsFn_(val) {\n\t\t\treturn !(0, _metal.isDefAndNotNull)(val) || (0, _metal.isObject)(val);\n\t\t}\n\t}, {\n\t\tkey: 'element',\n\t\tget: function get() {\n\t\t\treturn this.elementValue_;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (!(0, _metal.isElement)(val) && !(0, _metal.isString)(val) && (0, _metal.isDefAndNotNull)(val)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (val) {\n\t\t\t\tval = (0, _metalDom.toElement)(val) || this.elementValue_;\n\t\t\t}\n\n\t\t\tif (this.elementValue_ !== val) {\n\t\t\t\tvar prev = this.elementValue_;\n\t\t\t\tthis.elementValue_ = val;\n\t\t\t\tthis.handleComponentElementChanged_(prev, val);\n\t\t\t}\n\t\t}\n\t}], [{\n\t\tkey: 'isComponentCtor',\n\t\tvalue: function isComponentCtor(fn) {\n\t\t\treturn fn.prototype && fn.prototype[Component.COMPONENT_FLAG];\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(Ctor, opt_configOrElement, opt_element) {\n\t\t\tvar config = opt_configOrElement;\n\t\t\tvar element = opt_element;\n\t\t\tif ((0, _metal.isElement)(opt_configOrElement)) {\n\t\t\t\tconfig = null;\n\t\t\t\telement = opt_configOrElement;\n\t\t\t}\n\t\t\tvar instance = new Ctor(config, false);\n\t\t\tinstance.renderComponent(element);\n\t\t\treturn instance;\n\t\t}\n\n\t\t/**\n   * Creates and renders a component for the given constructor function as\n   * string. This will always make sure that the constructor runs without\n   * rendering the component, having the `render` step happen only after it\n   * has finished.\n   * @param {!function()} Ctor The component's constructor function.\n   * @param {Object|Element=} opt_configOrElement Optional config data or\n   *     parent for the component.\n   * @return {!String} The rendered component's content as string.\n   */\n\n\t}, {\n\t\tkey: 'renderToString',\n\t\tvalue: function renderToString(Ctor, opt_config) {\n\t\t\tvar rendererName = Ctor.RENDERER && Ctor.RENDERER.RENDERER_NAME;\n\t\t\tswitch (rendererName) {\n\t\t\t\tcase 'jsx':\n\t\t\t\tcase 'soy':\n\t\t\t\tcase 'incremental-dom':\n\t\t\t\t\t{\n\t\t\t\t\t\tif (typeof IncrementalDOM === 'undefined') {\n\t\t\t\t\t\t\tthrow new Error('Error. Trying to render incremental dom ' + 'based component to string requires IncrementalDOM ' + 'implementation to be loaded.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Incremental dom patches for components or nested components are\n\t\t\t\t\t\t// isolated inside the component element. The following code intercepts\n\t\t\t\t\t\t// incremental dom patches and collect results into temporary stack in\n\t\t\t\t\t\t// order to successfully collect the final string of the outermost\n\t\t\t\t\t\t// component after all nested components stack rendered.\n\t\t\t\t\t\tvar interceptedComponentStrings = [];\n\t\t\t\t\t\tvar patch = IncrementalDOM.patch;\n\t\t\t\t\t\tvar patchInterceptor = function patchInterceptor() {\n\t\t\t\t\t\t\tvar currentElement = patch.apply(null, arguments);\n\t\t\t\t\t\t\tinterceptedComponentStrings.push(currentElement.innerHTML);\n\t\t\t\t\t\t\tIncrementalDOM.patch = patch;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tIncrementalDOM.patch = patchInterceptor;\n\t\t\t\t\t\tComponent.render(Ctor, opt_config).dispose();\n\t\t\t\t\t\treturn interceptedComponentStrings[0];\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Error. Trying to render non incremental dom ' + 'based component to string.');\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Component;\n}(_metalEvents.EventEmitter);\n\n/**\n * Component data definition.\n * @type {Object}\n * @static\n */\n\n\nComponent.DATA = {\n\t/**\n  * Objects describing children elements that were passed to be rendered inside\n  * this component.\n  * @type {!Array<!Object>}\n  */\n\tchildren: {\n\t\tvalidator: Array.isArray,\n\t\tvalue: []\n\t},\n\n\t/**\n  * CSS classes to be applied to the element.\n  * @type {string}\n  */\n\telementClasses: {\n\t\tsetter: 'setterElementClassesFn_',\n\t\tvalidator: _metal.isString,\n\t\tvalue: ''\n\t},\n\n\t/**\n  * Listeners that should be attached to this component. Should be provided as\n  * an object, where the keys are event names and the values are the listener\n  * functions (or function names).\n  * @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}\n  */\n\tevents: {\n\t\tvalidator: 'validatorEventsFn_',\n\t\tvalue: null\n\t},\n\n\t/**\n  * Indicates if the component is visible or not.\n  * @type {boolean}\n  */\n\tvisible: {\n\t\tvalidator: _metal.isBoolean,\n\t\tvalue: true\n\t}\n};\n\n/**\n * Name of the flag used to identify component constructors via their prototype.\n * @type {string}\n */\nComponent.COMPONENT_FLAG = '__metal_component__';\n\n/**\n * The `ComponentDataManager` class that should be used. This class will be\n * responsible for handling the component's data. Each component may have its\n * own implementation.\n * @type {!ComponentDataManager}\n */\nComponent.DATA_MANAGER = _ComponentDataManager2.default;\n\n/**\n * CSS classes to be applied to the element.\n * @type {string}\n */\nComponent.ELEMENT_CLASSES = '';\n\n/**\n * The `ComponentRenderer` that should be used. Components need to set this\n * to a subclass of `ComponentRenderer` that has the rendering logic, like\n * `SoyRenderer`.\n * @type {!ComponentRenderer}\n */\nComponent.RENDERER = _ComponentRenderer2.default;\n\n/**\n * Flag indicating if component updates will happen synchronously. Updates are\n * done asynchronously by default, which allows changes to be batched and\n * applied together.\n * @type {boolean}\n */\nComponent.SYNC_UPDATES = false;\n\n/**\n * Sets a prototype flag to easily determine if a given constructor is for\n * a component or not.\n */\nComponent.prototype[Component.COMPONENT_FLAG] = true;\n\nvar proxyBlackList_ = {\n\teventsChanged: true,\n\tstateChanged: true,\n\tstateKeyChanged: true\n};\n\nexports.default = Component;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-component/lib/Component.js\n// module id = 55\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.syncState = syncState;\n\nvar _metal = require('metal');\n\nvar SYNC_FNS_KEY = '__METAL_SYNC_FNS__';\n\n/**\n * Gets the `sync` methods for this component's state. Caches the results in\n * the component's constructor whenever possible, so that this doesn't need to\n * be calculated again. It's not possible to cache the results when at least\n * one sync method is defined in the instance itself instead of in its\n * prototype, as it may be bound to the instance (not reusable by others).\n * @param {!Component} component\n * @return {!Object}\n * @private\n */\nfunction getSyncFns_(component) {\n\tvar ctor = component.constructor;\n\tif (ctor.hasOwnProperty(SYNC_FNS_KEY)) {\n\t\treturn ctor[SYNC_FNS_KEY];\n\t}\n\n\tvar fns = {};\n\tvar keys = component.getDataManager().getSyncKeys(component);\n\tvar canCache = true;\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar name = 'sync' + keys[i].charAt(0).toUpperCase() + keys[i].slice(1);\n\t\tvar fn = component[name];\n\t\tif (fn) {\n\t\t\tfns[keys[i]] = fn;\n\t\t\tcanCache = canCache && component.constructor.prototype[name];\n\t\t}\n\t}\n\n\tif (canCache) {\n\t\tctor[SYNC_FNS_KEY] = fns;\n\t}\n\treturn fns;\n}\n\n/**\n * Calls \"sync\" functions for the given component's state.\n * @param {!Component} component\n * @param {Object=} opt_changes When given, only the properties inside it will\n *     be synced. Otherwise all state properties will be synced.\n */\nfunction syncState(component, opt_changes) {\n\tvar syncFns = getSyncFns_(component);\n\tvar keys = Object.keys(opt_changes || syncFns);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar fn = syncFns[keys[i]];\n\t\tif ((0, _metal.isFunction)(fn)) {\n\t\t\tvar change = opt_changes && opt_changes[keys[i]];\n\t\t\tvar manager = component.getDataManager();\n\t\t\tfn.call(component, change ? change.newVal : manager.get(component, keys[i]), change ? change.prevVal : undefined);\n\t\t}\n\t}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-component/lib/sync/sync.js\n// module id = 56\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * The component registry is used to register components, so they can\n * be accessible by name.\n * @type {Object}\n */\nvar ComponentRegistry = function () {\n\tfunction ComponentRegistry() {\n\t\t_classCallCheck(this, ComponentRegistry);\n\t}\n\n\t_createClass(ComponentRegistry, null, [{\n\t\tkey: 'getConstructor',\n\n\t\t/**\n   * Gets the constructor function for the given component name, or\n   * undefined if it hasn't been registered yet.\n   * @param {string} name The component's name.\n   * @return {?function()}\n   * @static\n   */\n\t\tvalue: function getConstructor(name) {\n\t\t\tvar constructorFn = ComponentRegistry.components_[name];\n\t\t\tif (!constructorFn) {\n\t\t\t\tconsole.error('There\\'s no constructor registered for the component named ' + name + '.\\n\\t\\t\\t\\tComponents need to be registered via ComponentRegistry.register.');\n\t\t\t}\n\t\t\treturn constructorFn;\n\t\t}\n\n\t\t/**\n   * Registers a component, so it can be found by its name.\n   * @param {!Function} constructorFn The component's constructor function.\n   * @param {string=} opt_name Name of the registered component. If none is given\n   *   the name defined by the NAME static variable will be used instead. If that\n   *   isn't set as well, the name of the constructor function will be used.\n   * @static\n   */\n\n\t}, {\n\t\tkey: 'register',\n\t\tvalue: function register(constructorFn, opt_name) {\n\t\t\tvar name = opt_name;\n\t\t\tif (!name) {\n\t\t\t\tif (constructorFn.hasOwnProperty('NAME')) {\n\t\t\t\t\tname = constructorFn.NAME;\n\t\t\t\t} else {\n\t\t\t\t\tname = (0, _metal.getFunctionName)(constructorFn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconstructorFn.NAME = name;\n\t\t\tComponentRegistry.components_[name] = constructorFn;\n\t\t}\n\t}]);\n\n\treturn ComponentRegistry;\n}();\n\n/**\n * Holds all registered components, indexed by their names.\n * @type {!Object<string, function()>}\n * @protected\n * @static\n */\n\n\nComponentRegistry.components_ = {};\n\nexports.default = ComponentRegistry;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-component/lib/ComponentRegistry.js\n// module id = 57\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.disposeUnused = disposeUnused;\nexports.schedule = schedule;\n\nvar _data = require('../data');\n\nvar comps_ = [];\nvar disposing_ = false;\n\n/**\n * Disposes all sub components that were not rerendered since the last\n * time this function was scheduled.\n */\nfunction disposeUnused() {\n\tif (disposing_) {\n\t\treturn;\n\t}\n\tdisposing_ = true;\n\n\tfor (var i = 0; i < comps_.length; i++) {\n\t\tvar comp = comps_[i];\n\t\tif (!comp.isDisposed() && !(0, _data.getData)(comp).parent) {\n\t\t\t// Don't let disposing cause the element to be removed, since it may\n\t\t\t// be currently being reused by another component.\n\t\t\tcomp.element = null;\n\t\t\tcomp.dispose();\n\t\t}\n\t}\n\tcomps_ = [];\n\tdisposing_ = false;\n}\n\n/**\n * Schedules the given components to be checked and disposed if not used\n * anymore when `disposeUnused` is called.\n * @param {!Array<!Component>} comps\n */\nfunction schedule(comps) {\n\tfor (var i = 0; i < comps.length; i++) {\n\t\tif (!comps[i].isDisposed()) {\n\t\t\t(0, _data.getData)(comps[i]).parent = null;\n\t\t\tcomps_.push(comps[i]);\n\t\t}\n\t}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-incremental-dom/lib/cleanup/unused.js\n// module id = 58\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _metal = require('metal');\n\nvar _metalComponent = require('metal-component');\n\nvar _metalState = require('metal-state');\n\nvar _metalState2 = _interopRequireDefault(_metalState);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar JSXDataManager = function (_ComponentDataManager) {\n\t_inherits(JSXDataManager, _ComponentDataManager);\n\n\tfunction JSXDataManager() {\n\t\t_classCallCheck(this, JSXDataManager);\n\n\t\treturn _possibleConstructorReturn(this, (JSXDataManager.__proto__ || Object.getPrototypeOf(JSXDataManager)).apply(this, arguments));\n\t}\n\n\t_createClass(JSXDataManager, [{\n\t\tkey: 'addUnconfiguredProps_',\n\n\t\t/**\n   * Manually adds props that weren't configured via `PROPS`.\n   * @param {!Component} component\n   * @param {!State} props\n   * @param {!Object} data\n   * @protected\n   */\n\t\tvalue: function addUnconfiguredProps_(component, props, data) {\n\t\t\tvar keys = Object.keys(data);\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tif (!props.hasStateKey(keys[i])) {\n\t\t\t\t\tcomponent.props[keys[i]] = data[keys[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Overrides the original method so that we can have two separate `State`\n   * instances: one responsible for `state` and another for `props`.\n   * @param {!Component} comp\n   * @param {!Object} config\n   * @protected\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'createState_',\n\t\tvalue: function createState_(comp, config) {\n\t\t\tvar ctor = comp.constructor;\n\t\t\tcomp.props = {};\n\t\t\tcomp.state = {};\n\t\t\tvar data = this.getManagerData(comp);\n\n\t\t\tdata.props_ = new _metalState2.default(comp.getInitialConfig(), comp.props, comp);\n\t\t\tdata.props_.configState(_metal.object.mixin({}, config, (0, _metal.getStaticProperty)(ctor, 'PROPS', _metalState2.default.mergeState)));\n\t\t\tthis.addUnconfiguredProps_(comp, data.props_, comp.getInitialConfig());\n\n\t\t\tdata.state_ = new _metalState2.default({}, comp.state, comp);\n\t\t\tdata.state_.setEventData({\n\t\t\t\ttype: 'state'\n\t\t\t});\n\t\t\tdata.state_.configState(_metalState2.default.getStateStatic(ctor));\n\t\t}\n\n\t\t/**\n   * @inheritDoc\n   */\n\n\t}, {\n\t\tkey: 'dispose',\n\t\tvalue: function dispose(component) {\n\t\t\tvar data = this.getManagerData(component);\n\t\t\tdata.props_.dispose();\n\t\t\t_metalComponent.ComponentDataManager.dispose.call(this, component);\n\t\t}\n\n\t\t/**\n   * Overrides the original method so we can get properties from `props` by\n   * default.\n   * @param {!Component} component\n   * @param {string} name\n   * @return {*}\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(component, name) {\n\t\t\treturn this.getManagerData(component).props_.get(name);\n\t\t}\n\n\t\t/**\n   * Gets the `State` instance being used for \"props\".\n   * @param {!Component} component\n   * @return {!Object}\n   */\n\n\t}, {\n\t\tkey: 'getPropsInstance',\n\t\tvalue: function getPropsInstance(component) {\n\t\t\treturn this.getManagerData(component).props_;\n\t\t}\n\n\t\t/**\n   * Overrides the original method so we can enable \"sync\" methods just for\n   * `props`.\n   * @param {!Component} component\n   * @return {!Array<string>}\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'getSyncKeys',\n\t\tvalue: function getSyncKeys(component) {\n\t\t\treturn this.getManagerData(component).props_.getStateKeys();\n\t\t}\n\n\t\t/**\n   * Overrides the original method so we can replace values in `props`.\n   * @param {!Component} component\n   * @param {!Object} data\n   * @override\n   */\n\n\t}, {\n\t\tkey: 'replaceNonInternal',\n\t\tvalue: function replaceNonInternal(component, data) {\n\t\t\tvar prevProps = void 0;\n\t\t\tif (component.propsChanged) {\n\t\t\t\tprevProps = _metal.object.mixin({}, component.props);\n\t\t\t}\n\n\t\t\tvar props = this.getManagerData(component).props_;\n\t\t\t_metalComponent.ComponentDataManager.replaceNonInternal.call(this, component, data, props);\n\t\t\tthis.addUnconfiguredProps_(component, props, data);\n\t\t\tif (component.propsChanged) {\n\t\t\t\tcomponent.propsChanged(prevProps);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn JSXDataManager;\n}(_metalComponent.ComponentDataManager.constructor);\n\nexports.default = new JSXDataManager();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/metal-jsx/lib/JSXDataManager.js\n// module id = 59\n// module chunks = 0"],"sourceRoot":""}